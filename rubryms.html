<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Evaluador de Estudiantes por Rúbrica</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.14/jspdf.plugin.autotable.min.js"></script>
    <style>
        /* Estilos generales para el cuerpo y contenedor */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
        }
        .container {
            background-color: #ffffff;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            padding: 30px;
            max-width: 1000px;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 20px;
            transition: all 0.3s ease-in-out;
        }

        .flex flex-wrap gap-2 {
    width: 517.333334px;
}
        /* Estilos para textareas y botones */
        textarea {
            min-height: 150px;
            resize: vertical;
        }
        button {
            transition: background-color 0.3s ease, transform 0.2s ease;
        }
        button:hover {
            transform: translateY(-2px);
        }
        button:active {
            transform: translateY(0);
        }
        /* Estilos para mensajes de feedback */
        .message-box {
            background-color: #e0f2f7;
            color: #0288d1;
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            text-align: center;
            display: none;
        }
        .message-box.error {
            background-color: #ffebee;
            color: #d32f2f;
        }
        .message-box.success {
            background-color: #e8f5e9;
            color: #388e3c;
        }
        /* Estilos para niveles de desempeño */
        .performance-level {
            font-weight: bold;
            padding: 3px 8px;
            border-radius: 4px;
            margin-left: 10px;
        }
        .performance-level.previous {
            background-color: #ffcccc;
            color: #cc0000;
        }
        .performance-level.beginning {
            background-color: #ffebcc;
            color: #cc7a00;
        }
        .performance-level.process {
            background-color: #ffffcc;
            color: #999900;
        }
        .performance-level.achieved {
            background-color: #e6ffe6;
            color: #006600;
        }
        .performance-level.outstanding {
            background-color: #e6f7ff;
            color: #0066cc;
        }
        /* Estilos para la previsualización de la rúbrica */
        .rubric-preview {
            max-height: 500px;
            overflow-y: auto; /* Solo scroll vertical para el área total */
            margin-top: 10px;
        }
        .rubric-preview table {
            width: 100%; /* Ajuste a 100% para que el min-width lo fuerce */
            border-collapse: collapse;
        }
        .rubric-preview th, .rubric-preview td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        .rubric-preview th {
            background-color: #f2f2f2;
        }
        .rubric-preview textarea {
            /* min-height: 80px;  Eliminado, ahora h-28*/
            width: 100%;
            resize: vertical;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 4px;
        }
        .rubric-preview input {
            width: 100%;
            padding: 4px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        /* Estilos para el menú de navegación (escritorio por defecto) */
        .navbar {
            background-color: #4f46e5; /* Color morado oscuro */
            padding: 1rem;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            display: flex; /* Mostrar por defecto */
            justify-content: center; /* Centrar los elementos del menú */
            gap: 1rem; /* Espacio entre los botones */
            flex-wrap: wrap; /* Permitir que los elementos se envuelvan en pantallas pequeñas */
        }
        .navbar button {
            background-color: #6366f1; /* Un morado más claro para los botones */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            border: none;
            transition: background-color 0.3s ease, transform 0.2s ease;
            display: flex; /* Para alinear ícono y texto */
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        .navbar button:hover {
            background-color: #4338ca; /* Un morado más oscuro al pasar el ratón */
            transform: translateY(-2px);
        }
        .navbar button.active {
            background-color: #3730a3; /* Color para el botón activo */
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
            transform: none; /* Sin efecto de elevación para el activo */
        }

        /* Estilos para el menú hamburguesa (solo en móviles) */
        .hamburger-menu-header {
            background-color: #4f46e5;
            padding: 1rem;
            border-radius: 10px 10px 0 0; /* Bordes redondeados solo arriba */
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            display: none; /* Ocultar por defecto, se muestra con media query */
            justify-content: space-between;
            align-items: center;
            width: 100%; /* Asegura que ocupe todo el ancho del contenedor padre */
        }
        .mobile-nav-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(17, 24, 39, 0.95); /* bg-gray-900 con opacidad */
            z-index: 40;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 2rem;
            transition: transform 0.3s ease-out, opacity 0.3s ease-out;
            transform: translateX(100%); /* Ocultar por defecto */
            opacity: 0;
            pointer-events: none; /* No interactuable cuando está oculto */
        }
        .mobile-nav-overlay.open {
            transform: translateX(0%); /* Mostrar */
            opacity: 1;
            pointer-events: auto; /* Interactuable */
        }
        .mobile-nav-overlay .nav-mobile-item {
            color: white;
            font-size: 1.5rem; /* text-2xl */
            font-weight: 700; /* font-bold */
            cursor: pointer;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            background-color: #6366f1;
            transition: background-color 0.3s ease, transform 0.2s ease;
            display: flex; /* Para alinear ícono y texto */
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        .mobile-nav-overlay .nav-mobile-item:hover {
            background-color: #4338ca;
            transform: translateY(-2px);
        }
        .mobile-nav-overlay .nav-mobile-item.active {
            background-color: #3730a3;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
            transform: none;
        }
        .mobile-nav-overlay .close-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            color: white;
            font-size: 2.5rem; /* text-4xl */
            cursor: pointer;
        }

        /* Media Query para pantallas pequeñas (móviles) */
        @media (max-width: 767px) { /* Tailwind's 'md' breakpoint is 768px */
            .navbar {
                display: none; /* Ocultar la barra de navegación normal */
            }
            .hamburger-menu-header {
                display: flex; /* Mostrar el encabezado de la hamburguesa */
            }
            .container {
                padding-top: 0; /* Ajustar padding superior para el header fijo */
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Encabezado de la Aplicación con Logo y Nombre -->
        <div class="header-container flex flex-col md:flex-row items-center justify-center gap-4 mb-6">
            <img src="https://raw.githubusercontent.com/donarvy20/rubryms/refs/heads/main/ico.png" alt="Rubryms Logo" class="w-16 h-16 md:w-20 md:h-20 rounded-full shadow-md">
            <div class="text-center md:text-left">
                <h1 class="text-3xl md:text-4xl font-bold text-gray-800">Evaluador de Estudiantes</h1>
                <p class="text-xl md:text-2xl font-semibold text-purple-700">Rubryms</p>
            </div>
        </div>
        <!-- Fin Encabezado de la Aplicación -->

        <!-- Menú de Navegación Flexible para Escritorio -->
        <div class="navbar">
            <button id="nav-students-btn" class="active">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 20h2v-2a3 3 0 00-3-3H8a3 3 0 00-3 3v2H3M7 10h.01M17 10h.01M10 12h4m-4 2h4m-4 2h4M7 4h10a2 2 0 012 2v2a2 2 0 01-2 2H7a2 2 0 01-2-2V6a2 2 0 012-2zm0 0a2 2 0 012-2h4a2 2 0 012 2v2a2 2 0 01-2 2H9a2 2 0 01-2-2z"></path></svg>
                Estudiantes
            </button>
            <button id="nav-rubric-btn">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2m-2 0V3m0 2a2 2 0 012-2h4a2 2 0 012 2v2a2 2 0 01-2 2H9a2 2 0 01-2-2V7a2 2 0 012-2z"></path></svg>
                Rúbrica
            </button>
            <button id="nav-evaluation-btn" class="hidden">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                Evaluación
            </button>
            <button id="nav-report-btn" class="hidden">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 17v-2m3 2v-4m3 2v-6m2 9H7a2 2 0 01-2-2V5a2 2 0 012-2h10a2 2 0 012 2v14a2 2 0 01-2 2z"></path></svg>
                Reportes
            </button>
        </div>
        <!-- Fin Menú de Navegación de Escritorio -->

        <!-- Encabezado del Menú Hamburguesa para Móviles -->
        <div class="hamburger-menu-header">
            <h2 class="text-white text-xl font-bold">Menú Rubryms</h2>
            <button id="hamburger-btn" class="text-white focus:outline-none">
                <svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16m-7 6h7"></path></svg>
            </button>
        </div>
        <!-- Superposición del Menú Móvil -->
        <div id="mobile-nav-overlay" class="mobile-nav-overlay">
            <button id="close-mobile-nav-btn" class="close-btn">&times;</button>
            <button class="nav-mobile-item" data-target-section="add-students-section">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 20h2v-2a3 3 0 00-3-3H8a3 3 0 00-3 3v2H3M7 10h.01M17 10h.01M10 12h4m-4 2h4m-4 2h4M7 4h10a2 2 0 012 2v2a2 2 0 01-2 2H7a2 2 0 01-2-2V6a2 2 0 012-2zm0 0a2 2 0 012-2h4a2 2 0 012 2v2a2 2 0 01-2 2H9a2 2 0 01-2-2z"></path></svg>
                Estudiantes
            </button>
            <button class="nav-mobile-item" data-target-section="rubric-config-section">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2m-2 0V3m0 2a2 2 0 012-2h4a2 2 0 012 2v2a2 2 0 01-2 2H9a2 2 0 01-2-2V7a2 2 0 012-2z"></path></svg>
                Rúbrica
            </button>
            <button class="nav-mobile-item hidden" data-target-section="evaluation-section">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                Evaluación
            </button>
            <button class="nav-mobile-item hidden" data-target-section="report-section">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 17v-2m3 2v-4m3 2v-6m2 9H7a2 2 0 01-2-2V5a2 2 0 012-2h10a2 2 0 012 2v14a2 2 0 01-2 2z"></path></svg>
                Reportes
            </button>
        </div>
        <!-- Fin Menú Hamburguesa -->


        <!-- Sección de Añadir Estudiantes -->
        <div id="add-students-section" class="bg-blue-50 p-6 rounded-xl border border-blue-200">
            <h2 class="text-2xl font-semibold text-gray-700 mb-4 text-center">1. Agregar y Gestionar Estudiantes</h2>
            
            <div class="mb-4">
                <label for="group-name-input" class="block text-gray-700 font-medium mb-2">Nombre del Nuevo Grupo de Estudiantes (opcional):</label>
                <input
                    type="text"
                    id="group-name-input"
                    class="w-full p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 transition duration-200"
                    placeholder="Ej: Grupo A, Ciencias Sociales"
                />
            </div>

            <p class="text-gray-600 mb-2 text-center">Pega aquí la lista de nombres de tus estudiantes (uno por línea).</p>
            <textarea
                id="student-list-input"
                class="w-full p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 transition duration-200"
                placeholder="Ejemplo:&#10;Juan Pérez&#10;María García&#10;Carlos López"
            ></textarea>
            <button
                id="add-students-btn"
                class="w-full bg-blue-600 text-white font-semibold py-3 px-6 mt-4 rounded-xl shadow-md hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-300"
            >
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V4"></path></svg>
                Guardar Lista de Estudiantes
            </button>
            <div id="student-message-box" class="message-box"></div>

            <div class="mt-6 border-t pt-4 border-gray-200">
                <h3 class="text-xl font-semibold text-gray-700 mb-4 text-center">Seleccionar Grupo para Evaluación</h3>
                <p class="text-gray-600 mb-2 text-center">O elige un grupo existente para evaluar:</p>
                <select id="group-select" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 transition duration-200">
                    <option value="">-- Seleccionar Grupo --</option>
                </select>
                <button
                    id="select-group-btn"
                    class="w-full bg-indigo-600 text-white font-semibold py-3 px-6 mt-4 rounded-xl shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-4 focus:ring-indigo-300"
                >
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-3 7h3m-3 4h3m-6-4h.01M9 16h.01"></path></svg>
                    Cargar Grupo Seleccionado y Continuar
                </button>
                <button
                    id="delete-group-btn"
                    class="w-full bg-red-500 text-white font-semibold py-3 px-6 mt-2 rounded-xl shadow-md hover:bg-red-600 focus:outline-none focus:ring-4 focus:ring-red-300"
                >
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                    Eliminar Grupo Seleccionado
                </button>
            </div>
        </div>

        <!-- Sección de Configuración de Rúbrica (Ahora solo para crear/editar nuevas) -->
        <div id="rubric-config-section" class="bg-green-50 p-6 rounded-xl border border-green-200 hidden">
            <h2 class="text-2xl font-semibold text-gray-700 mb-4 text-center">2. Crear/Importar Rúbrica</h2>
            
            <div class="mb-6">
                <h3 class="text-xl font-semibold text-gray-700 mb-4">Importar Nueva Rúbrica desde CSV</h3>
                <p class="text-gray-600 mb-2">Formato requerido: Primera fila son los niveles de desempeño, primera columna son los aspectos a evaluar, celdas son los descriptores.</p>
                <label for="rubric-name-input" class="block text-gray-700 font-medium mb-2">Nombre de la Rúbrica:</label>
                <input
                    type="text"
                    id="rubric-name-input"
                    class="w-full p-3 border border-gray-300 rounded-lg focus:ring-green-500 focus:border-green-500 transition duration-200"
                    placeholder="Ej: Rúbrica de Presentaciones Orales"
                />
                <textarea
                    id="rubric-csv-input"
                    class="w-full p-3 border border-gray-300 rounded-lg focus:ring-green-500 focus:border-green-500 transition duration-200 mt-2"
                    placeholder='Pega aquí el contenido CSV de la rúbrica. Ejemplo:&#10;,Destacado,Logrado,En Proceso,En Inicio&#10;"Coherencia","Descriptor con, coma","Descriptor 2","Descriptor 3","Descriptor 4"&#10;"Claridad","Descriptor 1","Descriptor 2","Descriptor, con coma","Descriptor 4"'
                    rows="8"
                ></textarea>
                <div id="rubric-preview" class="rubric-preview hidden"></div>
                <button
                    id="preview-rubric-btn"
                    class="w-full bg-blue-500 text-white font-semibold py-2 px-4 mt-2 rounded-lg shadow-md hover:bg-blue-600 focus:outline-none focus:ring-4 focus:ring-blue-300"
                >
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>
                    Previsualizar Rúbrica
                </button>
            </div>
            <div id="rubric-config-message-box" class="message-box"></div>
        </div>

        <!-- Sección de Evaluación de Estudiantes (Ahora con selector de rúbrica) -->
        <div id="evaluation-section" class="bg-yellow-50 p-6 rounded-xl border border-yellow-200 hidden">
            <h2 class="text-2xl font-semibold text-gray-700 mb-4 text-center">3. Evaluación de Estudiantes</h2>
            
            <!-- Selector de Rúbrica (Movido aquí) -->
            <div class="mb-6 bg-yellow-100 p-4 rounded-lg border border-yellow-300">
                <h3 class="text-xl font-semibold text-gray-700 mb-4 text-center">Seleccionar Rúbrica para Evaluación</h3>
                <p class="text-gray-600 mb-2 text-center">Elige la rúbrica con la que deseas evaluar:</p>
                <select id="rubric-select" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-green-500 focus:border-green-500 transition duration-200">
                    <option value="">-- Seleccionar Rúbrica --</option>
                </select>
                <button
                    id="delete-rubric-btn"
                    class="w-full bg-red-500 text-white font-semibold py-2 px-4 mt-2 rounded-lg shadow-md hover:bg-red-600 focus:outline-none focus:ring-4 focus:ring-red-300"
                >
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                    Eliminar Rúbrica Seleccionada
                </button>
            </div>
            <!-- Fin Selector de Rúbrica -->

            <div class="text-center mb-4">
                <p class="text-lg text-gray-800 font-semibold">Estudiante Actual: <span id="current-student-name" class="text-blue-600"></span></p>
                <p class="text-gray-600 text-sm">Estudiante <span id="student-index">1</span> de <span id="total-students">0</span></p>
            </div>
            <div id="student-rubric-display" class="overflow-x-auto">
                <!-- La tabla de evaluación se renderizará aquí -->
            </div>
            <div class="flex flex-col sm:flex-row justify-center gap-4 mt-6">
                <button
                    id="prev-student-btn"
                    class="flex-1 bg-gray-400 text-white font-semibold py-3 px-6 rounded-xl shadow-md hover:bg-gray-500 focus:outline-none focus:ring-4 focus:ring-gray-300"
                >
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 15l-3-3m0 0l3-3m-3 3h8m-9 0a9 9 0 1118 0A9 9 0 0112 0z"></path></svg>
                    Anterior
                </button>
                <button
                    id="next-student-btn"
                    class="flex-1 bg-blue-600 text-white font-semibold py-3 px-6 rounded-xl shadow-md hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-300"
                >
                    Siguiente Estudiante
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 9l3 3m0 0l-3 3m3-3H8m-9 0a9 9 0 1118 0A9 9 0 0112 0z"></path></svg>
                </button>
                <button
                    id="finish-evaluation-btn"
                    class="flex-1 bg-indigo-600 text-white font-semibold py-3 px-6 rounded-xl shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-4 focus:ring-indigo-300 hidden"
                >
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>
                    Finalizar Evaluación y Exportar
                </button>
            </div>
            <div id="evaluation-message-box" class="message-box"></div>
        </div>

        <div id="report-section" class="bg-red-50 p-6 rounded-xl border border-red-200 hidden">
            <h2 class="text-2xl font-semibold text-gray-700 mb-4 text-center">4. Reporte y Exportación</h2>
            <p class="text-gray-600 mb-4 text-center">Haz clic para generar el reporte de todas las evaluaciones.</p>
            <div class="flex flex-col sm:flex-row justify-center gap-4 mt-6">
                <button
                    id="export-pdf-btn"
                    class="flex-1 bg-red-600 text-white font-semibold py-3 px-6 rounded-xl shadow-md hover:bg-red-700 focus:outline-none focus:ring-4 focus:ring-red-300"
                >
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 13h6m-3-3v6m5 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path></svg>
                    Exportar Reporte General a PDF
                </button>
                <button
                    id="export-individual-rubrics-btn"
                    class="flex-1 bg-teal-600 text-white font-semibold py-3 px-6 rounded-xl shadow-md hover:bg-teal-700 focus:outline-none focus:ring-4 focus:ring-teal-300"
                >
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 13h6m-3-3v6m5 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path></svg>
                    Exportar Rúbricas Individuales a PDF
                </button>
                <button
                    id="export-csv-btn"
                    class="flex-1 bg-green-600 text-white font-semibold py-3 px-6 rounded-xl shadow-md hover:bg-green-700 focus:outline-none focus:ring-4 focus:ring-green-300"
                >
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path></svg>
                    Exportar a CSV
                </button>
            </div>
            <div class="flex flex-col sm:flex-row justify-center gap-4 mt-4">
                <button
                    id="back-to-evaluation-btn"
                    class="flex-1 bg-gray-600 text-white font-semibold py-3 px-6 rounded-xl shadow-md hover:bg-gray-700 focus:outline-none focus:ring-4 focus:ring-gray-300"
                >
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 15l-3-3m0 0l3-3m-3 3h8m-9 0a9 9 0 1118 0A9 9 0 0112 0z"></path></svg>
                    Atrás (Modificar Evaluación)
                </button>
                <button
                    id="new-rubric-btn"
                    class="flex-1 bg-blue-600 text-white font-semibold py-3 px-6 rounded-xl shadow-md hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-300"
                >
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path></svg>
                    Nueva Evaluación
                </button>
            </div>
            <div id="report-message-box" class="message-box"></div>
        </div>

        <!-- Footer -->
        <div class="footer-container text-center text-gray-600 text-sm mt-8 pt-4 border-t border-gray-200">
            <p>Derechos Reservados &copy; 2025 Rubryms</p>
            <p>Developed by YJMS</p>
            <p class="mt-2 flex items-center justify-center gap-1">
                <!-- Icono de correo SVG -->
                <svg class="w-4 h-4 inline-block text-blue-500" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.003 5.884L10 9.882l7.997-3.998A2 2 0 0016 4H4a2 2 0 00-1.997 1.884z"></path><path d="M18 8.118l-8 4-8-4V14a2 2 0 002 2h12a2 2 0 002-2V8.118z"></path></svg>
                <a href="mailto:donarvy20@gmail.com" class="text-blue-600 hover:underline">donarvy20@gmail.com</a>
            </p>
        </div>
        <!-- Fin Footer -->

    </div>

    <script>
        // Obtener referencias a los elementos del DOM
        const addStudentsSection = document.getElementById('add-students-section');
        const groupNameInput = document.getElementById('group-name-input');
        const studentListInput = document.getElementById('student-list-input');
        const addStudentsBtn = document.getElementById('add-students-btn');
        const groupSelect = document.getElementById('group-select');
        const selectGroupBtn = document.getElementById('select-group-btn');
        const deleteGroupBtn = document.getElementById('delete-group-btn');
        const studentMessageBox = document.getElementById('student-message-box');

        const rubricConfigSection = document.getElementById('rubric-config-section');
        // const rubricSelect = document.getElementById('rubric-select'); // Movido a evaluation-section
        // const deleteRubricBtn = document.getElementById('delete-rubric-btn'); // Movido a evaluation-section
        const rubricNameInput = document.getElementById('rubric-name-input');
        const rubricCsvInput = document.getElementById('rubric-csv-input');
        const rubricPreview = document.getElementById('rubric-preview');
        const previewRubricBtn = document.getElementById('preview-rubric-btn');
        const saveRubricBtn = document.getElementById('save-rubric-btn'); // Aunque se oculta, su referencia es útil
        const rubricConfigMessageBox = document.getElementById('rubric-config-message-box');

        const evaluationSection = document.getElementById('evaluation-section');
        const rubricSelect = document.getElementById('rubric-select'); // Nueva ubicación
        const deleteRubricBtn = document.getElementById('delete-rubric-btn'); // Nueva ubicación
        const currentStudentName = document.getElementById('current-student-name');
        const studentIndexSpan = document.getElementById('student-index');
        const totalStudentsSpan = document.getElementById('total-students');
        const studentRubricDisplay = document.getElementById('student-rubric-display');
        const prevStudentBtn = document.getElementById('prev-student-btn');
        const nextStudentBtn = document.getElementById('next-student-btn');
        const finishEvaluationBtn = document.getElementById('finish-evaluation-btn');
        const evaluationMessageBox = document.getElementById('evaluation-message-box');

        const reportSection = document.getElementById('report-section');
        const exportPdfBtn = document.getElementById('export-pdf-btn');
        const exportIndividualRubricsBtn = document.getElementById('export-individual-rubrics-btn');
        const exportCsvBtn = document.getElementById('export-csv-btn');
        const backToEvaluationBtn = document.getElementById('back-to-evaluation-btn');
        const newRubricBtn = document.getElementById('new-rubric-btn');
        const reportMessageBox = document.getElementById('report-message-box');

        // Navegación
        const navStudentsBtn = document.getElementById('nav-students-btn');
        const navRubricBtn = document.getElementById('nav-rubric-btn');
        const navEvaluationBtn = document.getElementById('nav-evaluation-btn');
        const navReportBtn = document.getElementById('nav-report-btn');

        // Referencias para el menú hamburguesa
        const hamburgerBtn = document.getElementById('hamburger-btn');
        const mobileNavOverlay = document.getElementById('mobile-nav-overlay');
        const closeMobileNavBtn = document.getElementById('close-mobile-nav-btn');
        const navMobileItems = document.querySelectorAll('.nav-mobile-item');


        // Variables globales para la aplicación
        let studentGroups = {};
        let currentStudents = [];
        let currentStudentIndex = 0;
        let savedRubrics = {};
        let currentRubric = null;
        let evaluations = {};
        let temporaryRubric = null; // Para la edición de la rúbrica antes de guardar


        // --- Funciones de Navegación ---
        /**
         * Muestra una sección específica de la aplicación y actualiza los botones de navegación.
         * @param {string} sectionId - El ID de la sección a mostrar (ej: 'add-students-section').
         */
        function showSection(sectionId) {
            const sections = [addStudentsSection, rubricConfigSection, evaluationSection, reportSection];
            sections.forEach(section => {
                if (section.id === sectionId) {
                    section.classList.remove('hidden');
                } else {
                    section.classList.add('hidden');
                }
            });

            // Actualizar botones de navegación de escritorio activos
            const navButtons = [navStudentsBtn, navRubricBtn, navEvaluationBtn, navReportBtn];
            navButtons.forEach(btn => {
                const btnSectionName = btn.id.replace('nav-', '').replace('-btn', '');
                const targetSectionName = sectionId.replace('-section', '').replace('add-', '');

                if (btnSectionName === targetSectionName) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });

            // Actualizar la visibilidad de los botones de navegación para escritorio y móvil
            updateNavButtonVisibility();
        }

        /**
         * Actualiza la visibilidad de los botones de navegación (escritorio y móvil)
         * basándose en el estado actual de estudiantes y rúbricas.
         */
        function updateNavButtonVisibility() {
            const currentGroupName = groupSelect.value;
            const hasEvaluationsForCurrentGroup = Object.keys(evaluations).some(key => key.startsWith(`${currentGroupName}_`));

            // Botones de escritorio
            navRubricBtn.classList.toggle('hidden', currentStudents.length === 0 && Object.keys(studentGroups).length === 0);
            navEvaluationBtn.classList.toggle('hidden', currentStudents.length === 0 || !currentRubric);
            navReportBtn.classList.toggle('hidden', !(currentStudents.length > 0 && currentRubric && hasEvaluationsForCurrentGroup));

            // Botones de navegación móvil (en el overlay)
            document.querySelector('#mobile-nav-overlay button[data-target-section="rubric-config-section"]').classList.toggle('hidden', currentStudents.length === 0 && Object.keys(studentGroups).length === 0);
            document.querySelector('#mobile-nav-overlay button[data-target-section="evaluation-section"]').classList.toggle('hidden', currentStudents.length === 0 || !currentRubric);
            document.querySelector('#mobile-nav-overlay button[data-target-section="report-section"]').classList.toggle('hidden', !(currentStudents.length > 0 && currentRubric && hasEvaluationsForCurrentGroup));
        }


        // Event listeners para la navegación de escritorio
        navStudentsBtn.addEventListener('click', () => showSection('add-students-section'));
        navRubricBtn.addEventListener('click', () => {
            if (currentStudents.length === 0 && Object.keys(studentGroups).length === 0) {
                showMessage(rubricConfigMessageBox, "Para configurar una rúbrica, primero debes cargar o añadir un grupo de estudiantes en la sección 'Estudiantes'.", 'error');
                return;
            }
            showSection('rubric-config-section');
        });
        navEvaluationBtn.addEventListener('click', () => {
            if (currentStudents.length === 0) {
                showMessage(evaluationMessageBox, "Para evaluar, primero debes cargar o añadir un grupo de estudiantes.", 'error');
                return;
            }
            if (!currentRubric) {
                showMessage(evaluationMessageBox, "Para evaluar, primero debes seleccionar o crear una rúbrica en la sección 'Rúbrica'.", 'error');
                return;
            }
            showSection('evaluation-section');
            renderStudentEvaluation(); // Asegura que la evaluación se renderice al volver
        });
        navReportBtn.addEventListener('click', () => {
            const currentGroupName = groupSelect.value;
            const hasEvaluationsForCurrentGroup = Object.keys(evaluations).some(key => key.startsWith(`${currentGroupName}_`));
            
            if (currentStudents.length === 0 || !currentRubric || !hasEvaluationsForCurrentGroup) {
                showMessage(reportMessageBox, "Para ver reportes, asegúrate de tener un grupo de estudiantes cargado, una rúbrica seleccionada y haber realizado al menos una evaluación.", 'error');
                return;
            }
            showSection('report-section');
        });

        // Event listeners para el menú hamburguesa
        hamburgerBtn.addEventListener('click', () => {
            mobileNavOverlay.classList.add('open'); // Abrir el overlay
        });

        closeMobileNavBtn.addEventListener('click', () => {
            mobileNavOverlay.classList.remove('open'); // Cerrar el overlay
        });

        navMobileItems.forEach(item => {
            item.addEventListener('click', (event) => {
                const targetSection = event.target.dataset.targetSection;
                // Ejecutar la lógica de navegación de escritorio
                if (targetSection === 'add-students-section') showSection('add-students-section');
                else if (targetSection === 'rubric-config-section') navRubricBtn.click(); // Usar el click programático para activar lógica
                else if (targetSection === 'evaluation-section') navEvaluationBtn.click();
                else if (targetSection === 'report-section') navReportBtn.click();

                mobileNavOverlay.classList.remove('open'); // Cerrar el overlay después de la selección
            });
        });


        // --- Funciones de Utilidad --- 

        /**
         * Muestra un mensaje de feedback al usuario en un cuadro específico.
         * @param {HTMLElement} boxElement - El elemento DOM donde se mostrará el mensaje.
         * @param {string} message - El texto del mensaje.
         * @param {string} type - El tipo de mensaje ('success', 'error', o vacío para información).
         */
        function showMessage(boxElement, message, type = '') {
            boxElement.textContent = message;
            boxElement.className = 'message-box'; // Reiniciar clases
            if (type) {
                boxElement.classList.add(type);
            }
            boxElement.style.display = 'block';
            setTimeout(() => {
                boxElement.style.display = 'none';
            }, 5000); // El mensaje desaparece después de 5 segundos
        }

        /**
         * Parsea una cadena CSV, manejando comas dentro de comillas.
         * @param {string} text - La cadena CSV a parsear.
         * @returns {Array<Array<string>>} Una matriz de filas y columnas.
         */
        function parseCSV(text) {
            const lines = text.split('\n').filter(line => line.trim() !== '');
            const result = [];
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const current = [];
                let inQuotes = false;
                let buffer = '';
                
                for (let j = 0; j < line.length; j++) {
                    const char = line[j];
                    
                    if (char === '"') {
                        // Manejar comillas escapadas (ej: "" dentro de un campo)
                        if (inQuotes && line[j + 1] === '"') {
                            buffer += '"';
                            j++; // Saltar la siguiente comilla
                        } else {
                            inQuotes = !inQuotes;
                        }
                    } else if (char === ',' && !inQuotes) {
                        current.push(buffer.trim());
                        buffer = '';
                    } else {
                        buffer += char;
                    }
                }
                
                current.push(buffer.trim()); // Añadir el último campo de la línea
                result.push(current);
            }
            return result;
        }

        /**
         * Carga los datos guardados en localStorage al iniciar la aplicación.
         */
        function loadData() {
            try {
                const storedStudentGroups = localStorage.getItem('studentGroups');
                if (storedStudentGroups) {
                    studentGroups = JSON.parse(storedStudentGroups);
                    renderGroupSelect();
                }

                const storedRubrics = localStorage.getItem('savedRubrics');
                if (storedRubrics) {
                    savedRubrics = JSON.parse(storedRubrics);
                    renderRubricSelect(); // Renderizar selector de rúbricas al cargar
                }

                const storedCurrentGroup = localStorage.getItem('currentSelectedGroup');
                if(storedCurrentGroup && studentGroups[storedCurrentGroup]) {
                    currentStudents = studentGroups[storedCurrentGroup];
                    groupSelect.value = storedCurrentGroup;
                }

                const storedCurrentRubric = localStorage.getItem('currentRubric');
                if (storedCurrentRubric) {
                    currentRubric = JSON.parse(storedCurrentRubric);
                    rubricSelect.value = currentRubric.name; // Seleccionar la rúbrica cargada en el nuevo select
                }

                const storedEvaluations = localStorage.getItem('evaluations');
                if (storedEvaluations) {
                    evaluations = JSON.parse(storedEvaluations);
                }
                
                // Determinar qué sección mostrar al cargar, priorizando el flujo de trabajo
                if (currentStudents.length > 0 && currentRubric) {
                    showSection('evaluation-section');
                    renderStudentEvaluation();
                } else if (currentStudents.length > 0) {
                    showSection('rubric-config-section'); // Ir a configurar rúbrica si hay estudiantes pero no rúbrica seleccionada
                } else {
                    showSection('add-students-section'); // Sino, empezar por añadir estudiantes
                }
                updateNavButtonVisibility(); // Asegurarse de que los botones de navegación estén correctos al cargar
            } catch (e) {
                console.error("Error al cargar datos de localStorage:", e);
                showMessage(studentMessageBox, "Error al cargar datos guardados. Los datos pueden estar corruptos.", 'error');
            }
        }

        /**
         * Guarda todos los datos relevantes en localStorage.
         */
        function saveData() {
            try {
                localStorage.setItem('studentGroups', JSON.stringify(studentGroups));
                localStorage.setItem('savedRubrics', JSON.stringify(savedRubrics));
                localStorage.setItem('evaluations', JSON.stringify(evaluations));
                localStorage.setItem('currentSelectedGroup', groupSelect.value);
                if (currentRubric) {
                    localStorage.setItem('currentRubric', JSON.stringify(currentRubric));
                }
                updateNavButtonVisibility(); // Actualizar visibilidad después de guardar datos
            } catch (e) {
                console.error("Error al guardar datos en localStorage:", e);
                showMessage(studentMessageBox, "No se pudieron guardar los datos. Verifique el espacio disponible en su navegador.", 'error');
            }
        }

        /**
         * Reinicia el estado de la evaluación actual, manteniendo grupos y rúbricas guardadas.
         */
        function resetApp() {
            localStorage.removeItem('currentRubric');
            localStorage.removeItem('evaluations');

            currentRubric = null;
            evaluations = {};
            currentStudentIndex = 0; // Reiniciar índice del estudiante

            rubricNameInput.value = ''; // Limpiar el campo de nombre de rúbrica
            rubricCsvInput.value = ''; // Limpiar el campo CSV de rúbrica
            rubricPreview.classList.add('hidden'); // Ocultar la previsualización
            
            renderRubricSelect(); // Volver a renderizar el selector de rúbricas en evaluación para reflejar `currentRubric = null`

            showSection('rubric-config-section'); // Volver a la configuración de rúbrica
            showMessage(reportMessageBox, "La evaluación ha sido reiniciada. Tus grupos y rúbricas permanecen guardados.", 'success');
            updateNavButtonVisibility(); // Actualizar visibilidad de nav al resetear
        }

        // --- Lógica de Añadir y Gestionar Estudiantes --- 

        /**
         * Renderiza las opciones del selector de grupos de estudiantes.
         */
        function renderGroupSelect() {
            groupSelect.innerHTML = '<option value="">-- Seleccionar Grupo --</option>';
            for (const groupName in studentGroups) {
                const option = document.createElement('option');
                option.value = groupName;
                option.textContent = groupName;
                groupSelect.appendChild(option);
            }
            // Asegurar que el grupo seleccionado actualmente se mantenga visible si existe
            const storedCurrentGroup = localStorage.getItem('currentSelectedGroup');
            if (storedCurrentGroup && studentGroups[storedCurrentGroup]) {
                groupSelect.value = storedCurrentGroup;
            }
        }

        addStudentsBtn.addEventListener('click', () => {
            const rawList = studentListInput.value.trim();
            let groupName = groupNameInput.value.trim();
            const selectedGroupOption = groupSelect.value; // Obtener el grupo seleccionado en el dropdown

            if (!rawList) {
                showMessage(studentMessageBox, "Por favor, introduce la lista de estudiantes.", 'error');
                return;
            }

            const newStudents = rawList.split('\n')
                                        .map(name => name.trim())
                                        .filter(name => name !== '')
                                        .filter((name, index, self) => self.indexOf(name) === index); // Eliminar duplicados

            if (newStudents.length === 0) {
                showMessage(studentMessageBox, "No se encontraron nombres de estudiantes válidos en la lista.", 'error');
                return;
            }

            let targetGroupName;
            let actionMessage = "";

            if (groupName) { // Si se ha introducido un nombre de grupo en el input
                targetGroupName = groupName;
                // Si el grupo ya existe, combinar, sino, crear nuevo
                if (studentGroups[targetGroupName]) {
                    const existingStudents = studentGroups[targetGroupName];
                    const combinedStudents = [...new Set([...existingStudents, ...newStudents])]; // Combinar y eliminar duplicados
                    studentGroups[targetGroupName] = combinedStudents;
                    actionMessage = `¡${newStudents.length} estudiantes añadidos al grupo "${targetGroupName}"! Total: ${combinedStudents.length} estudiantes.`;
                } else {
                    studentGroups[targetGroupName] = newStudents;
                    actionMessage = `¡Nuevo grupo "${targetGroupName}" con ${newStudents.length} estudiantes guardado!`;
                }
            } else if (selectedGroupOption) { // Si hay un grupo seleccionado en el dropdown y NO se introdujo un nuevo nombre
                targetGroupName = selectedGroupOption;
                const existingStudents = studentGroups[targetGroupName] || [];
                const combinedStudents = [...new Set([...existingStudents, ...newStudents])];
                studentGroups[targetGroupName] = combinedStudents;
                actionMessage = `¡${newStudents.length} estudiantes añadidos al grupo "${targetGroupName}"! Total: ${combinedStudents.length} estudiantes.`;
            } else { // Ni nombre de grupo nuevo ni grupo seleccionado
                targetGroupName = `Grupo - ${new Date().toLocaleDateString('es-ES')}`;
                let counter = 1;
                while(studentGroups[targetGroupName]) { // Evitar sobrescribir si el nombre generado ya existe
                    targetGroupName = `Grupo - ${new Date().toLocaleDateString('es-ES')} (${counter})`;
                    counter++;
                }
                studentGroups[targetGroupName] = newStudents;
                actionMessage = `¡Nuevo grupo anónimo "${targetGroupName}" con ${newStudents.length} estudiantes creado!`;
            }

            currentStudents = studentGroups[targetGroupName];
            renderGroupSelect();
            groupSelect.value = targetGroupName; // Seleccionar el grupo recién creado/actualizado
            saveData();
            showMessage(studentMessageBox, actionMessage, 'success');

            groupNameInput.value = '';
            studentListInput.value = '';
            showSection('add-students-section'); // Mantenerse en la sección de estudiantes después de guardar
            updateNavButtonVisibility(); // Actualizar visibilidad de nav
        });

        selectGroupBtn.addEventListener('click', () => {
            const selectedGroup = groupSelect.value;
            if (!selectedGroup) {
                showMessage(studentMessageBox, "Por favor, selecciona un grupo de estudiantes.", 'error');
                return;
            }

            currentStudents = studentGroups[selectedGroup];
            saveData();
            showMessage(studentMessageBox, `¡Grupo "${selectedGroup}" cargado para evaluación!`, 'success');

            // Después de seleccionar un grupo, ir a la sección de rúbrica si no hay rúbrica activa,
            // o a la sección de evaluación si ya hay una rúbrica activa.
            if (currentRubric) {
                showSection('evaluation-section');
                renderStudentEvaluation();
            } else {
                showSection('rubric-config-section');
            }
            currentStudentIndex = 0; // Reiniciar el índice del estudiante al cambiar de grupo
            updateNavButtonVisibility(); // Actualizar visibilidad de nav
        });

        deleteGroupBtn.addEventListener('click', () => {
            const selectedGroup = groupSelect.value;
            if (!selectedGroup) {
                showMessage(studentMessageBox, "Por favor, selecciona un grupo para eliminar.", 'error');
                return;
            }

            // Usar un modal personalizado en lugar de window.confirm
            const customConfirm = createCustomConfirm(`¿Estás seguro de que quieres eliminar el grupo "${selectedGroup}"? Ten en cuenta que esto NO eliminará las evaluaciones asociadas a este grupo si ya se han realizado. Para borrar evaluaciones individuales, necesitarías reiniciar la rúbrica.`);
            customConfirm.then(result => {
                if (result) {
                    delete studentGroups[selectedGroup];
                    // También eliminar evaluaciones asociadas a este grupo
                    for (const key in evaluations) {
                        if (key.startsWith(`${selectedGroup}_`)) {
                            delete evaluations[key];
                        }
                    }

                    if (localStorage.getItem('currentSelectedGroup') === selectedGroup) {
                        localStorage.removeItem('currentSelectedGroup');
                        currentStudents = []; // Limpiar estudiantes actuales si se elimina el grupo activo
                    }
                    renderGroupSelect();
                    saveData();
                    showMessage(studentMessageBox, `Grupo "${selectedGroup}" eliminado.`, 'success');
                    // Si el grupo actual es eliminado, volver a la sección de añadir estudiantes
                    if (!currentStudents.length) {
                        showSection('add-students-section');
                    } else {
                        showSection('add-students-section'); // Refrescar vista
                    }
                    updateNavButtonVisibility(); // Actualizar visibilidad de nav
                }
            });
        });

        // --- Lógica de Configuración de Rúbrica --- 

        /**
         * Renderiza las opciones del selector de rúbricas guardadas.
         */
        function renderRubricSelect() {
            rubricSelect.innerHTML = '<option value="">-- Seleccionar Rúbrica --</option>';
            for (const rubricName in savedRubrics) {
                const option = document.createElement('option');
                option.value = rubricName;
                option.textContent = rubricName;
                rubricSelect.appendChild(option);
            }
            // Asegurar que la rúbrica seleccionada actualmente se mantenga visible si existe
            if (currentRubric && savedRubrics[currentRubric.name]) {
                rubricSelect.value = currentRubric.name;
            }
        }

        /**
         * Parsea una cadena CSV, manejando comas dentro de comillas.
         * @param {string} text - La cadena CSV a parsear.
         * @returns {Array<Array<string>>} Una matriz de filas y columnas.
         */
        function parseCSV(text) {
            const lines = text.split('\n').filter(line => line.trim() !== '');
            const result = [];
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const current = [];
                let inQuotes = false;
                let buffer = '';
                
                for (let j = 0; j < line.length; j++) {
                    const char = line[j];
                    
                    if (char === '"') {
                        // Manejar comillas escapadas (ej: "" dentro de un campo)
                        if (inQuotes && line[j + 1] === '"') {
                            buffer += '"';
                            j++; // Saltar la siguiente comilla
                        } else {
                            inQuotes = !inQuotes;
                        }
                    } else if (char === ',' && !inQuotes) {
                        current.push(buffer.trim());
                        buffer = '';
                    } else {
                        buffer += char;
                    }
                }
                
                current.push(buffer.trim()); // Añadir el último campo de la línea
                result.push(current);
            }
            return result;
        }

        /**
         * Parsea el texto CSV de la rúbrica en un objeto de rúbrica.
         * @param {string} csvText - El contenido CSV de la rúbrica.
         * @returns {Object|null} El objeto de la rúbrica o null si hay un error.
         */
        function parseRubricFromCSV(csvText) {
            const parsedData = parseCSV(csvText);
            if (parsedData.length < 2) {
                showMessage(rubricConfigMessageBox, "El formato del CSV no es válido. Debe tener al menos 2 líneas (encabezados de niveles y al menos un aspecto).", 'error');
                return null;
            }

            // Extraer niveles (primera fila, omitiendo la primera celda vacía)
            const levels = parsedData[0].slice(1).map(level => level.replace(/^"|"$/g, '').trim());
            if (levels.length === 0) {
                showMessage(rubricConfigMessageBox, "No se encontraron niveles de desempeño en la primera fila del CSV.", 'error');
                return null;
            }

            // Extraer aspectos y descriptores
            const aspects = [];
            const descriptors = {};
            const levelScores = {};
            
            // Asignar puntajes predeterminados basados en la posición (del más alto al más bajo)
            // Se asume que el nivel más a la izquierda (índice 0) es el de mayor puntaje.
            levels.forEach((level, index) => {
                levelScores[level] = levels.length - index; // Ejemplo: si hay 5 niveles, el primero es 5, el segundo 4, etc.
            });

            for (let i = 1; i < parsedData.length; i++) {
                const row = parsedData[i];
                const aspect = row[0].replace(/^"|"$/g, '').trim();
                if (!aspect) continue; // Saltar filas sin nombre de aspecto

                aspects.push(aspect);
                descriptors[aspect] = {};

                for (let j = 1; j < row.length; j++) {
                    const level = levels[j - 1]; // Coincide con el índice de los niveles en la primera fila
                    if (level) { // Asegurarse de que el nivel existe
                        descriptors[aspect][level] = row[j] ? row[j].replace(/^"|"$/g, '').trim() : '';
                    }
                }
            }

            if (aspects.length === 0) {
                showMessage(rubricConfigMessageBox, "No se encontraron aspectos válidos en el CSV. Asegúrate de que la primera columna contenga los nombres de los aspectos.", 'error');
                return null;
            }
            if (aspects.some(aspect => !descriptors[aspect] || Object.keys(descriptors[aspect]).length === 0)) {
                showMessage(rubricConfigMessageBox, "Algunos aspectos no tienen descriptores asociados a los niveles definidos.", 'error');
                return null;
            }

            return {
                name: rubricNameInput.value.trim() || `Rúbrica ${new Date().toLocaleDateString('es-ES')}`,
                aspects,
                levels,
                descriptors,
                levelScores,
                generalObservations: "" // Campo para futuras observaciones generales
            };
        }

        /**
         * Muestra una previsualización editable de la rúbrica para que el usuario pueda ajustarla.
         * @param {Object} rubricData - El objeto de la rúbrica a previsualizar/editar.
         */
        function showEditableRubric(rubricData) {
            let previewHTML = '<h4 class="font-semibold mb-2 text-center text-lg">Revisa y Edita tu Rúbrica:</h4>';
            
            // Nombre editable
            previewHTML += `
                <div class="mb-4">
                    <label for="editable-rubric-name" class="block text-gray-700 font-medium mb-2">Nombre de la Rúbrica:</label>
                    <input type="text" id="editable-rubric-name" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500" value="${rubricData.name}">
                </div>
            `;
            
            // Tabla editable - AHORA CON min-w para forzar desborde y con estilos visuales
            previewHTML += `
                <div class="overflow-x-auto border border-gray-300 rounded-lg bg-white shadow-sm p-4">
                    <table class="min-w-[1500px] border-collapse">
                        <thead>
                            <tr>
                                <th class="p-2 border bg-gray-100 min-w-[200px]">Aspecto</th>
                                ${rubricData.levels.map((level, index) => `
                                    <th class="p-2 border bg-gray-100 min-w-[250px]">
                                        <input type="text" class="w-full p-1 border-b border-gray-300 text-center rounded-sm" value="${level}" 
                                               data-level-index="${index}" onchange="updateRubricLevel(this)">
                                        <label for="score-${level.replace(/\s/g, '-')}-${index}" class="block text-gray-700 text-xs mt-1">Puntaje:</label>
                                        <input type="number" id="score-${level.replace(/\s/g, '-')}-${index}" class="w-full p-1 mt-1 border-b border-gray-300 text-center rounded-sm" 
                                               value="${rubricData.levelScores[level]}" min="0" max="100" step="0.5"
                                               data-level-index="${index}" onchange="updateRubricScore(this)">
                                    </th>
                                `).join('')}
                            </tr>
                        </thead>
                        <tbody>
                            ${rubricData.aspects.map((aspect, aspectIndex) => `
                                <tr>
                                    <td class="p-2 border"><input type="text" class="w-full p-1 border-b border-gray-300 rounded-sm" 
                                            value="${aspect}" data-aspect-index="${aspectIndex}" onchange="updateRubricAspect(this)"></td>
                                    ${rubricData.levels.map((level, levelIndex) => `
                                        <td class="p-2 border">
                                            <textarea class="w-full p-1 border border-gray-300 h-48 rounded-sm" 
                                                      data-aspect-index="${aspectIndex}" data-level-index="${levelIndex}"
                                                      onchange="updateRubricDescriptor(this)">${rubricData.descriptors[aspect][level] || ''}</textarea>
                                        </td>
                                    `).join('')}
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            `;
            
            // Botones de acción
            previewHTML += `
                <div class="mt-4 flex flex-col sm:flex-row justify-between gap-4">
                    <button id="cancel-edit-rubric-btn" class="flex-1 bg-gray-500 text-white px-4 py-2 rounded-xl shadow-md hover:bg-gray-600 focus:outline-none focus:ring-4 focus:ring-gray-300">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                        Cancelar Edición
                    </button>
                    <button id="confirm-save-rubric-btn" class="flex-1 bg-green-600 text-white px-4 py-2 rounded-xl shadow-md hover:bg-green-700 focus:outline-none focus:ring-4 focus:ring-green-300">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V4"></path></svg>
                        Confirmar y Guardar Rúbrica
                    </button>
                </div>
            `;
            
            rubricPreview.innerHTML = previewHTML;
            rubricPreview.classList.remove('hidden');
            // Ocultar el botón original "Previsualizar Rúbrica" y los inputs de nombre/CSV cuando la previsualización editable está activa
            previewRubricBtn.classList.add('hidden'); 
            rubricNameInput.classList.add('hidden');
            rubricCsvInput.classList.add('hidden');


            // Crear una copia profunda para `temporaryRubric` para evitar modificar `rubricData` directamente
            // hasta que se confirme el guardado.
            temporaryRubric = JSON.parse(JSON.stringify(rubricData)); 

            // Eventos para los botones de edición de la previsualización
            document.getElementById('cancel-edit-rubric-btn').addEventListener('click', () => {
                rubricPreview.classList.add('hidden');
                rubricCsvInput.value = ''; // Limpiar el input CSV
                rubricNameInput.value = ''; // Limpiar el nombre de la rúbrica
                temporaryRubric = null; // Limpiar la rúbrica temporal
                previewRubricBtn.classList.remove('hidden'); // Mostrar el botón original
                rubricNameInput.classList.remove('hidden');
                rubricCsvInput.classList.remove('hidden');
            });
            
            document.getElementById('confirm-save-rubric-btn').addEventListener('click', () => {
                // Actualizamos el nombre por si fue editado
                const newRubricName = document.getElementById('editable-rubric-name').value.trim();
                if (!newRubricName) {
                    showMessage(rubricConfigMessageBox, "El nombre de la rúbrica no puede estar vacío.", 'error');
                    return;
                }
                
                // Si el nombre ha cambiado y ya existe otra rúbrica con ese nombre
                if (newRubricName !== rubricData.name && savedRubrics[newRubricName]) {
                    showMessage(rubricConfigMessageBox, `Ya existe una rúbrica con el nombre "${newRubricName}". Por favor, elige un nombre diferente.`, 'error');
                    return;
                }

                temporaryRubric.name = newRubricName;

                // Verificar si hay niveles o aspectos vacíos o con puntajes inválidos en la rúbrica temporal
                if (temporaryRubric.levels.some(level => !level.trim())) {
                    showMessage(rubricConfigMessageBox, "Todos los nombres de niveles deben estar definidos.", 'error');
                    return;
                }
                if (temporaryRubric.aspects.some(aspect => !aspect.trim())) {
                    showMessage(rubricConfigMessageBox, "Todos los nombres de aspectos deben estar definidos.", 'error');
                    return;
                }
                for (const level of temporaryRubric.levels) {
                    const score = temporaryRubric.levelScores[level];
                    if (score === undefined || isNaN(score) || score < 0) {
                        showMessage(rubricConfigMessageBox, `El puntaje para el nivel "${level}" no es válido. Debe ser un número positivo.`, 'error');
                        return;
                    }
                }

                // Eliminar la rúbrica antigua si el nombre ha cambiado
                if (rubricData.name && rubricData.name !== newRubricName) {
                    delete savedRubrics[rubricData.name];
                    // Si la rúbrica actual era la que se renombró, limpiarla para forzar la carga de la nueva
                    if (currentRubric && currentRubric.name === rubricData.name) {
                        currentRubric = null;
                        localStorage.removeItem('currentRubric');
                    }
                }
                
                // Guardar la rúbrica editada
                savedRubrics[temporaryRubric.name] = temporaryRubric;
                currentRubric = temporaryRubric; // Establecer la rúbrica editada como la actual
                saveData();
                renderRubricSelect(); // Actualizar la lista de rúbricas guardadas

                rubricPreview.classList.add('hidden');
                rubricCsvInput.value = ''; // Limpiar el input CSV
                rubricNameInput.value = ''; // Limpiar el nombre de la rúbrica
                temporaryRubric = null; // Limpiar la rúbrica temporal
                previewRubricBtn.classList.remove('hidden'); // Mostrar el botón original
                rubricNameInput.classList.remove('hidden');
                rubricCsvInput.classList.remove('hidden');

                showMessage(rubricConfigMessageBox, `¡Rúbrica "${currentRubric.name}" guardada y lista para la evaluación!`, 'success');
                showSection('evaluation-section'); // Avanzar a la sección de evaluación
                currentStudentIndex = 0; // Reiniciar índice del estudiante
                renderStudentEvaluation();
                updateNavButtonVisibility(); // Actualizar visibilidad de nav
            });
        }

        // Funciones para actualizar la rúbrica temporal durante la edición (accesibles globalmente)
        window.updateRubricLevel = function(input) {
            const levelIndex = parseInt(input.dataset.levelIndex);
            const newLevelName = input.value.trim();
            const oldLevelName = temporaryRubric.levels[levelIndex];
            
            if (newLevelName && newLevelName !== oldLevelName) {
                // Verificar si el nuevo nombre de nivel ya existe (excepto si es el mismo nivel)
                if (temporaryRubric.levels.includes(newLevelName) && temporaryRubric.levels.indexOf(newLevelName) !== levelIndex) {
                    showMessage(rubricConfigMessageBox, `El nivel "${newLevelName}" ya existe. Por favor, elige un nombre único.`, 'error');
                    input.value = oldLevelName; // Revertir al valor anterior
                    return;
                }
                // Actualizamos el nombre del nivel en la lista de niveles
                temporaryRubric.levels[levelIndex] = newLevelName;
                
                // Si el nombre cambió, actualizamos las claves en levelScores y descriptors
                temporaryRubric.levelScores[newLevelName] = temporaryRubric.levelScores[oldLevelName];
                delete temporaryRubric.levelScores[oldLevelName];
                
                temporaryRubric.aspects.forEach(aspect => {
                    if (temporaryRubric.descriptors[aspect] && temporaryRubric.descriptors[aspect][oldLevelName] !== undefined) {
                        temporaryRubric.descriptors[aspect][newLevelName] = temporaryRubric.descriptors[aspect][oldLevelName];
                        delete temporaryRubric.descriptors[aspect][oldLevelName];
                    }
                });
            } else if (!newLevelName) {
                showMessage(rubricConfigMessageBox, "El nombre del nivel no puede estar vacío.", 'error');
                input.value = oldLevelName; // Revertir al valor anterior
            }
        };

        window.updateRubricScore = function(input) {
            const levelIndex = parseInt(input.dataset.levelIndex);
            const levelName = temporaryRubric.levels[levelIndex];
            const newScore = parseFloat(input.value);

            if (!isNaN(newScore) && newScore >= 0) {
                temporaryRubric.levelScores[levelName] = newScore;
            } else {
                showMessage(rubricConfigMessageBox, `El puntaje para el nivel "${levelName}" no es válido. Debe ser un número positivo.`, 'error');
                input.value = temporaryRubric.levelScores[levelName]; // Revertir al valor anterior
            }
        };

        window.updateRubricAspect = function(input) {
            const aspectIndex = parseInt(input.dataset.aspectIndex);
            const newAspectName = input.value.trim();
            const oldAspectName = temporaryRubric.aspects[aspectIndex];
            
            if (newAspectName && newAspectName !== oldAspectName) {
                // Check for duplicate aspect names within the temporary rubric
                if (temporaryRubric.aspects.includes(newAspectName) && temporaryRubric.aspects.indexOf(newAspectName) !== aspectIndex) {
                    showMessage(rubricConfigMessageBox, `El aspecto "${newAspectName}" ya existe. Por favor, elige un nombre único.`, 'error');
                    input.value = oldAspectName; // Revertir al valor anterior
                    return;
                }
                
                // Update the aspect name in the list
                temporaryRubric.aspects[aspectIndex] = newAspectName;
                
                // Update the key in the descriptors object
                if (temporaryRubric.descriptors[oldAspectName]) {
                    temporaryRubric.descriptors[newAspectName] = temporaryRubric.descriptors[oldAspectName];
                    delete temporaryRubric.descriptors[oldAspectName];
                } else {
                    temporaryRubric.descriptors[newAspectName] = {}; // Crear si no existía
                }
            } else if (!newAspectName) {
                showMessage(rubricConfigMessageBox, "El nombre del aspecto no puede estar vacío.", 'error');
                input.value = oldAspectName; // Revertir al valor anterior
            }
        };

        window.updateRubricDescriptor = function(textarea) {
            const aspectIndex = parseInt(textarea.dataset.aspectIndex);
            const levelIndex = parseInt(textarea.dataset.levelIndex);
            const aspectName = temporaryRubric.aspects[aspectIndex];
            const levelName = temporaryRubric.levels[levelIndex];
            
            if (!temporaryRubric.descriptors[aspectName]) {
                temporaryRubric.descriptors[aspectName] = {};
            }
            temporaryRubric.descriptors[aspectName][levelName] = textarea.value.trim();
        };

        previewRubricBtn.addEventListener('click', () => {
            const rubricName = rubricNameInput.value.trim();
            const csvText = rubricCsvInput.value.trim();

            if (!csvText) {
                showMessage(rubricConfigMessageBox, "Por favor, pega el contenido CSV de la rúbrica.", 'error');
                return;
            }
            if (!rubricName) {
                 showMessage(rubricConfigMessageBox, "Por favor, introduce un nombre para la rúbrica.", 'error');
                 return;
            }
            // Verificar si el nombre ya existe y no estamos editando esa misma rúbrica
            if (savedRubrics[rubricName] && savedRubrics[rubricName] !== currentRubric) {
                showMessage(rubricConfigMessageBox, `Ya existe una rúbrica con el nombre "${rubricName}". Por favor, elige un nombre diferente o cárgala desde el selector.`, 'error');
                return;
            }


            const parsedRubric = parseRubricFromCSV(csvText);
            if (parsedRubric) {
                parsedRubric.name = rubricName; // Asegurar que el nombre del input se use
                showEditableRubric(parsedRubric);
                showMessage(rubricConfigMessageBox, "Rúbrica analizada correctamente. Puedes modificarla antes de guardar.", 'success');
            }
        });

        rubricSelect.addEventListener('change', () => {
            const selectedRubricName = rubricSelect.value;
            // Cuando se selecciona una rúbrica del dropdown en la sección de evaluación,
            // se limpia la previsualización de la sección de configuración.
            rubricPreview.classList.add('hidden'); 
            previewRubricBtn.classList.remove('hidden'); 
            rubricNameInput.classList.remove('hidden');
            rubricCsvInput.classList.remove('hidden');

            if (selectedRubricName && savedRubrics[selectedRubricName]) {
                currentRubric = savedRubrics[selectedRubricName];
                saveData();
                
                showMessage(evaluationMessageBox, `¡Rúbrica "${selectedRubricName}" cargada y lista para la evaluación!`, 'success');
                renderStudentEvaluation(); // Renderizar la evaluación con la nueva rúbrica
                updateNavButtonVisibility(); // Actualizar visibilidad de nav
            } else {
                currentRubric = null; // Si no se selecciona nada, limpiar la rúbrica actual
                localStorage.removeItem('currentRubric');
                // No mostrar mensaje si la opción es "Seleccionar Rúbrica"
                if (selectedRubricName !== "") {
                    showMessage(evaluationMessageBox, "No hay una rúbrica válida seleccionada. Por favor, elige una.", 'error');
                }
                renderStudentEvaluation(); // Asegurar que la tabla de evaluación se vacíe
                updateNavButtonVisibility(); // Actualizar visibilidad de nav
            }
            // Limpiar los campos de input y textarea si se selecciona una rúbrica existente
            rubricNameInput.value = '';
            rubricCsvInput.value = '';
        });

        deleteRubricBtn.addEventListener('click', () => {
            const selectedRubricName = rubricSelect.value;
            if (!selectedRubricName) {
                showMessage(evaluationMessageBox, "Por favor, selecciona una rúbrica para eliminar.", 'error');
                return;
            }

            const customConfirm = createCustomConfirm(`¿Estás seguro de que quieres eliminar la rúbrica "${selectedRubricName}"? Esto no eliminará las evaluaciones que ya la usaron.`);
            customConfirm.then(result => {
                if (result) {
                    delete savedRubrics[selectedRubricName];
                    if (currentRubric && currentRubric.name === selectedRubricName) {
                        currentRubric = null;
                        localStorage.removeItem('currentRubric');
                    }
                    saveData();
                    renderRubricSelect(); // Volver a renderizar el selector
                    showMessage(evaluationMessageBox, `Rúbrica "${selectedRubricName}" eliminada.`, 'success');
                    renderStudentEvaluation(); // Actualizar la vista de evaluación (probablemente vacía)
                    updateNavButtonVisibility(); // Actualizar visibilidad de nav
                }
            });
        });

        // --- Lógica de Evaluación de Estudiantes --- 

        /**
         * Determina el nivel de desempeño basado en el promedio de puntajes.
         * @param {number} averageScore - El puntaje promedio del estudiante.
         * @returns {{level: string, class: string}} Objeto con el nombre del nivel y la clase CSS.
         */
        function getPerformanceLevel(averageScore) {
            // Ajustar estos rangos y nombres según las necesidades.
            if (averageScore === 0) return { level: "No evaluado", class: "" }; // Manejar caso sin evaluación
            if (averageScore >= 1 && averageScore < 2) return { level: "Previo al inicio", class: "previous" }; 
            if (averageScore >= 2 && averageScore < 3) return { level: "Inicio", class: "beginning" }; 
            if (averageScore >= 3 && averageScore < 4) return { level: "En proceso", class: "process" }; 
            if (averageScore >= 4 && averageScore < 5) return { level: "Logrado", class: "achieved" }; 
            if (averageScore >= 5) return { level: "Destacado", class: "outstanding" }; 
            return { level: "Inválido", class: "" }; // Para puntajes fuera de rango esperados
        }

        /**
         * Renderiza la tabla de evaluación para el estudiante actual.
         */
        function renderStudentEvaluation() {
            if (!currentRubric || currentStudents.length === 0) {
                currentStudentName.textContent = "No hay estudiantes o rúbrica";
                studentRubricDisplay.innerHTML = `<p class="text-center text-gray-500">Por favor, carga un grupo de estudiantes y una rúbrica para comenzar la evaluación.</p>`;
                finishEvaluationBtn.classList.add('hidden');
                nextStudentBtn.classList.add('hidden');
                prevStudentBtn.classList.add('hidden');
                return;
            }

            const studentName = currentStudents[currentStudentIndex];
            currentStudentName.textContent = studentName;
            studentIndexSpan.textContent = currentStudentIndex + 1;
            totalStudentsSpan.textContent = currentStudents.length;

            const evaluationKey = `${groupSelect.value}_${studentName}`;

            let tableHTML = ` 
                <table class="min-w-full bg-white border border-gray-300 rounded-lg overflow-hidden shadow-sm"> 
                    <thead class="bg-gray-100"> 
                        <tr> 
                            <th class="py-3 px-4 text-left text-gray-700 font-semibold border-b">Aspecto</th> 
                            <!-- Eliminar la columna "Nivel Asignado" -->
                            <th class="py-3 px-4 text-left text-gray-700 font-semibold border-b">Puntaje</th> 
                            <th class="py-3 px-4 text-left text-gray-700 font-semibold border-b">Descriptores (Haz clic para asignar)</th> 
                        </tr> 
                    </thead> 
                    <tbody> 
            `; 

            let totalScore = 0; 
            let evaluatedAspectsCount = 0; 

            currentRubric.aspects.forEach(aspect => { 
                const currentLevel = evaluations[evaluationKey] ? evaluations[evaluationKey][aspect] : null; 
                const currentScore = currentLevel ? currentRubric.levelScores[currentLevel] || 0 : 0; 
                
                if (currentLevel) { 
                    totalScore += currentScore; 
                    evaluatedAspectsCount++; 
                } 
                
                tableHTML += ` 
                    <tr> 
                        <td class="py-3 px-4 border-b text-gray-800 font-medium">${aspect}</td> 
                        <td class="py-3 px-4 border-b"> 
                            <span class="font-bold text-green-600">${currentScore}</span> 
                        </td> 
                        <td class="py-2 px-4 border-b"> 
                            <div class="flex flex-wrap gap-2" style="width: 500px;"> 
                           
                                ${currentRubric.levels.map(level => { 
                                    const descriptor = currentRubric.descriptors[aspect] ? currentRubric.descriptors[aspect][level] || 'Sin descriptor' : 'Sin descriptor'; 
                                    const isSelected = currentLevel === level; 
                                    const buttonClasses = ` 
                                        flex-grow min-w-[220px] p-2 text-sm border rounded-md cursor-pointer 
                                        ${isSelected ? 'bg-blue-200 border-blue-500 text-blue-800 shadow-md' : 'bg-gray-100 border-gray-300 text-gray-700 hover:bg-gray-200'} 
                                        transition duration-200 ease-in-out 
                                        text-left 
                                    `; 
                                    return ` 
                                        <button 
                                            data-aspect="${aspect}" 
                                            data-level="${level}" 
                                            class="${buttonClasses}" 
                                            title="${descriptor}" 
                                        > 
                                            <span class="font-semibold">${level} (${currentRubric.levelScores[level] || 0} pts):</span> ${descriptor} 
                                        </button> 
                                    `; 
                                }).join('')} 
                            </div> 
                        </td> 
                    </tr> 
                `; 
            }); 

            const averageScore = evaluatedAspectsCount > 0 ? (totalScore / currentRubric.aspects.length).toFixed(1) : 0; // Promedio sobre todos los aspectos de la rúbrica
            const performanceLevel = getPerformanceLevel(parseFloat(averageScore)); 

            tableHTML += ` 
                    </tbody> 
                    <tfoot> 
                        <tr> 
                            <td class="py-3 px-4 border-t font-bold text-gray-800">Puntaje Total del Estudiante</td> 
                            <td class="py-3 px-4 border-t font-bold text-gray-800"></td> <!-- Se mantiene vacío o se ajusta colspan si se eliminan más columnas -->
                            <td class="py-3 px-4 border-t font-bold text-green-600">${totalScore}</td> 
                            <td class="py-3 px-4 border-t font-bold text-gray-800"></td> 
                        </tr> 
                        <tr> 
                            <td class="py-3 px-4 border-t font-bold text-gray-800">Promedio General</td> 
                            <td class="py-3 px-4 border-t font-bold text-gray-800"></td> <!-- Se mantiene vacío o se ajusta colspan -->
                            <td class="py-3 px-4 border-t font-bold text-green-600">${averageScore}</td> 
                            <td class="py-3 px-4 border-t font-bold text-gray-800"> 
                                <span class="performance-level ${performanceLevel.class}">${performanceLevel.level}</span> 
                            </td> 
                        </tr> 
                    </tfoot> 
                </table> 
                <div class="mt-4 p-3 bg-gray-50 rounded-lg"> 
                    <h4 class="font-semibold mb-2">Rúbrica: ${currentRubric.name}</h4> 
                </div> 
            `; 
            studentRubricDisplay.innerHTML = tableHTML; 

            studentRubricDisplay.querySelectorAll('button[data-aspect][data-level]').forEach(button => { 
                button.addEventListener('click', (event) => { 
                    const aspect = event.currentTarget.dataset.aspect; 
                    const level = event.currentTarget.dataset.level; 
                    evaluateAspect(studentName, aspect, level); 
                }); 
            }); 

            prevStudentBtn.disabled = currentStudentIndex === 0; 
            nextStudentBtn.disabled = currentStudentIndex === currentStudents.length - 1; 
            if (currentStudentIndex === currentStudents.length - 1 && currentStudents.length > 0) { 
                finishEvaluationBtn.classList.remove('hidden'); 
                nextStudentBtn.classList.add('hidden'); 
            } else { 
                finishEvaluationBtn.classList.add('hidden'); 
                nextStudentBtn.classList.remove('hidden'); 
            }
            showSection(evaluationSection.id); // Asegurarse de que la sección de evaluación esté visible
        } 

        /**
         * Asigna un nivel de desempeño a un aspecto para un estudiante dado.
         * @param {string} studentName - El nombre del estudiante.
         * @param {string} aspect - El aspecto a evaluar.
         * @param {string} level - El nivel de desempeño a asignar.
         */
        function evaluateAspect(studentName, aspect, level) { 
            const evaluationKey = `${groupSelect.value}_${studentName}`; 
            if (!evaluations[evaluationKey]) { 
                evaluations[evaluationKey] = {}; 
            } 
            evaluations[evaluationKey][aspect] = level; 
            saveData(); 
            renderStudentEvaluation(); 
            showMessage(evaluationMessageBox, `Evaluación para '${aspect}' del estudiante '${studentName}' actualizada a '${level}'.`, 'success'); 
            updateNavButtonVisibility(); // Actualizar visibilidad de nav (especialmente para reportes)
        } 

        prevStudentBtn.addEventListener('click', () => { 
            if (currentStudentIndex > 0) { 
                currentStudentIndex--; 
                renderStudentEvaluation(); 
            } 
        }); 

        nextStudentBtn.addEventListener('click', () => { 
            if (currentStudentIndex < currentStudents.length - 1) { 
                currentStudentIndex++; 
                renderStudentEvaluation(); 
            } 
        }); 

        finishEvaluationBtn.addEventListener('click', () => { 
            showSection('report-section'); 
        }); 

        backToEvaluationBtn.addEventListener('click', () => { 
            showSection('evaluation-section'); 
            renderStudentEvaluation(); 
        }); 

        newRubricBtn.addEventListener('click', () => { 
            const customConfirm = createCustomConfirm("¿Estás seguro de que quieres iniciar una nueva evaluación? Esto borrará las evaluaciones actuales pero mantendrá tus grupos y rúbricas guardadas.");
            customConfirm.then(result => {
                if (result) {
                    resetApp(); 
                }
            });
        }); 

        // --- Lógica de Exportación a PDF y CSV --- 

        /**
         * Genera un reporte PDF individual para un estudiante.
         * @param {string} studentName - El nombre del estudiante.
         * @param {string} groupName - El nombre del grupo al que pertenece el estudiante.
         */
        function generateSingleStudentPdf(studentName, groupName) { 
            const { jsPDF } = window.jspdf; 
            const doc = new jsPDF({ 
                orientation: 'landscape', 
                unit: 'mm', 
                format: 'a4' 
            }); 

            doc.setFont("helvetica"); 
            let yOffset = 20; 
            const margin = 20; 
            const evaluationKey = `${groupName}_${studentName}`;

            // Título y encabezado 
            doc.setFontSize(22); 
            doc.setTextColor(40, 40, 40); 
            doc.text("Rúbrica de Evaluación", doc.internal.pageSize.width / 2, yOffset, { align: 'center' }); 
            yOffset += 10; 

            doc.setFontSize(14); 
            doc.setTextColor(50, 50, 50); 
            doc.text(`Grupo: ${groupName || 'N/A'}`, doc.internal.pageSize.width / 2, yOffset, { align: 'center' }); 
            yOffset += 10; 

            doc.setFontSize(10); 
            doc.setTextColor(80, 80, 80); 
            doc.text(`Rúbrica: ${currentRubric.name || 'N/A'}`, margin, yOffset); 
            yOffset += 5; 
            doc.text(`Estudiante: ${studentName || 'N/A'}`, margin, yOffset); 
            yOffset += 15; 

            // Primero mostramos la matriz completa de la rúbrica
            doc.setFontSize(12);
            doc.setTextColor(0, 0, 0);
            doc.text("Matriz Completa de la Rúbrica y Evaluación:", margin, yOffset);
            yOffset += 7;

            // Encabezados para la matriz de rúbrica
            const rubricHeaders = ["Aspecto", ...currentRubric.levels.map(level => `${level} (${currentRubric.levelScores[level]} pts)`)];
            const colWidth = (doc.internal.pageSize.width - (margin * 2) - 40) / currentRubric.levels.length;
            const rubricColumnWidths = [40, ...Array(currentRubric.levels.length).fill(colWidth)];

            const rubricTableData = currentRubric.aspects.map(aspect => {
                return [aspect, ...currentRubric.levels.map(level => currentRubric.descriptors[aspect] ? currentRubric.descriptors[aspect][level] || '' : '')];
            });

            doc.autoTable({
                startY: yOffset,
                head: [rubricHeaders],
                body: rubricTableData,
                theme: 'grid',
                styles: {
                    fontSize: 6,
                    cellPadding: 1,
                    valign: 'middle',
                    halign: 'left',
                    textColor: [50, 50, 50],
                },
                headStyles: {
                    fillColor: [220, 220, 220],
                    textColor: [0, 0, 0],
                    fontStyle: 'bold',
                },
                columnStyles: rubricHeaders.reduce((acc, _, index) => {
                    acc[index] = { cellWidth: rubricColumnWidths[index] };
                    return acc;
                }, {}),
                didDrawCell: function (data) {
                    if (data.section === 'body' && data.column.index > 0) { // Solo para celdas de descriptores
                        const aspectName = currentRubric.aspects[data.row.index];
                        const levelName = currentRubric.levels[data.column.index - 1]; // -1 porque la primera columna es el aspecto
                        const assignedLevel = evaluations[evaluationKey] ? evaluations[evaluationKey][aspectName] : null;

                        if (assignedLevel === levelName) {
                            doc.setFillColor(199, 230, 248); // Fondo azul claro para el descriptor seleccionado
                            doc.rect(data.cell.x, data.cell.y, data.cell.width, data.cell.height, 'F');
                            doc.setTextColor(0, 0, 0); // Texto negro para contraste
                            doc.setFont(undefined, 'bold'); // Texto en negrita
                            // Redibujar el texto para que la negrita y el color se apliquen correctamente
                            doc.text(data.cell.text, data.cell.x + data.cell.padding('left'), data.cell.y + data.cell.padding('top'));
                        }
                    }
                },
                didDrawPage: function (data) {
                    let str = "Página " + doc.internal.getNumberOfPages();
                    doc.setFontSize(8);
                    doc.setTextColor(150);
                    doc.text(str, data.settings.margin.left, doc.internal.pageSize.height - 10);
                }
            });

            yOffset = doc.autoTable.previous.finalY + 10;

            // No se muestra la tabla de evaluación separada si ya está integrada en la matriz
            // Solo el resumen final

            let studentTotalScore = 0;
            let hasEvaluatedAspects = false;
            currentRubric.aspects.forEach(aspect => {
                const assignedLevel = evaluations[evaluationKey] ? evaluations[evaluationKey][aspect] || 'No Evaluado' : 'No Evaluado';
                const scoreForAspect = currentRubric.levelScores[assignedLevel] || 0;
                if (assignedLevel !== 'No Evaluado') {
                    studentTotalScore += scoreForAspect;
                    hasEvaluatedAspects = true;
                }
            });

            let maxPossibleScore = 0;
            currentRubric.aspects.forEach(aspect => {
                let maxAspectScore = 0;
                currentRubric.levels.forEach(level => {
                    const score = currentRubric.levelScores[level] || 0;
                    if (score > maxAspectScore) {
                        maxAspectScore = score;
                    }
                });
                maxPossibleScore += maxAspectScore;
            });

            const studentAverageScore = hasEvaluatedAspects ? (studentTotalScore / currentRubric.aspects.length).toFixed(1) : 'N/A';
            const performanceLevel = getPerformanceLevel(parseFloat(studentAverageScore));

            // Resumen final
            doc.setFontSize(10);
            doc.setTextColor(0, 100, 0);
            doc.text(`Puntaje Final: ${studentTotalScore} / ${maxPossibleScore} pts`, margin, yOffset + 5);
            doc.text(`Promedio por Aspecto: ${studentAverageScore}`, margin, yOffset + 10);
            doc.text(`Nivel de Desempeño: ${performanceLevel.level}`, margin, yOffset + 15);

            const safeStudentName = studentName.replace(/[^a-zA-Z0-9]/g, '_'); // Limpiar nombre para el archivo
            const safeGroupName = groupName.replace(/[^a-zA-Z0-9]/g, '_'); // Limpiar nombre para el archivo
            doc.save(`rubrica_${safeStudentName}_${safeGroupName}.pdf`); 
        } 

        exportIndividualRubricsBtn.addEventListener('click', async () => { 
            if (currentStudents.length === 0) { 
                showMessage(reportMessageBox, "No hay estudiantes en el grupo actual para generar reportes individuales.", 'error'); 
                return; 
            } 
            if (!currentRubric) { 
                showMessage(reportMessageBox, "No hay una rúbrica seleccionada para exportar.", 'error'); 
                return; 
            } 

            const currentGroupName = groupSelect.value; 
            for (const student of currentStudents) { 
                generateSingleStudentPdf(student, currentGroupName); 
            } 
            showMessage(reportMessageBox, "¡Rúbricas individuales generadas y descargadas!", 'success'); 
        }); 

        exportPdfBtn.addEventListener('click', async () => { 
            if (currentStudents.length === 0) { 
                showMessage(reportMessageBox, "No hay estudiantes en el grupo actual para generar el reporte.", 'error'); 
                return; 
            } 
            if (!currentRubric) { 
                showMessage(reportMessageBox, "No hay una rúbrica seleccionada para exportar.", 'error'); 
                return; 
            } 

            const { jsPDF } = window.jspdf; 
            const doc = new jsPDF({ 
                orientation: 'landscape', 
                unit: 'mm', 
                format: 'a4' 
            }); 

            doc.setFont("helvetica"); 

            const currentGroupName = groupSelect.value; 
            let totalSumOfFinalScores = 0; 
            let evaluatedStudentCount = 0; 

            for (const student of currentStudents) { 
                doc.addPage(); // Añadir una nueva página para cada estudiante en el reporte general
                let yOffset = 20; 
                const margin = 20; 
                const evaluationKey = `${currentGroupName}_${student}`;

                doc.setFontSize(22); 
                doc.setTextColor(40, 40, 40); 
                doc.text("Rúbrica de Evaluación", doc.internal.pageSize.width / 2, yOffset, { align: 'center' }); 
                yOffset += 10; 

                doc.setFontSize(14); 
                doc.setTextColor(50, 50, 50); 
                doc.text(`Grupo: ${currentGroupName || 'N/A'}`, doc.internal.pageSize.width / 2, yOffset, { align: 'center' }); 
                yOffset += 10; 

                doc.setFontSize(10); 
                doc.setTextColor(80, 80, 80); 
                doc.text(`Rúbrica: ${currentRubric.name || 'N/A'}`, margin, yOffset); 
                yOffset += 5; 
                doc.text(`Estudiante: ${student || 'N/A'}`, margin, yOffset); 
                yOffset += 10; 

                // Matriz completa de la rúbrica con descriptores marcados para el reporte general también
                doc.setFontSize(12);
                doc.setTextColor(0, 0, 0);
                doc.text("Matriz Completa de la Rúbrica y Evaluación:", margin, yOffset);
                yOffset += 7;

                const rubricHeaders = ["Aspecto", ...currentRubric.levels.map(level => `${level} (${currentRubric.levelScores[level]} pts)`)];
                const colWidth = (doc.internal.pageSize.width - (margin * 2) - 40) / currentRubric.levels.length;
                const rubricColumnWidths = [40, ...Array(currentRubric.levels.length).fill(colWidth)];

                doc.autoTable({
                    startY: yOffset,
                    head: [rubricHeaders],
                    body: currentRubric.aspects.map(aspect => [aspect, ...currentRubric.levels.map(level => currentRubric.descriptors[aspect] ? currentRubric.descriptors[aspect][level] || '' : '')]),
                    theme: 'grid',
                    styles: {
                        fontSize: 8,
                        cellPadding: 1,
                        valign: 'middle',
                        halign: 'left',
                        textColor: [50, 50, 50],
                    },
                    headStyles: {
                        fillColor: [220, 220, 220],
                        textColor: [0, 0, 0],
                        fontStyle: 'bold',
                    },
                    columnStyles: rubricHeaders.reduce((acc, _, index) => {
                        acc[index] = { cellWidth: rubricColumnWidths[index] };
                        return acc;
                    }, {}),
                    didDrawCell: function (data) {
                        if (data.section === 'body' && data.column.index > 0) {
                            const aspectName = currentRubric.aspects[data.row.index];
                            const levelName = currentRubric.levels[data.column.index - 1];
                            const assignedLevel = evaluations[evaluationKey] ? evaluations[evaluationKey][aspectName] : null;

                            if (assignedLevel === levelName) {
                                doc.setFillColor(199, 230, 248); // Fondo azul claro para el descriptor seleccionado
                                doc.rect(data.cell.x, data.cell.y, data.cell.width, data.cell.height, 'F');
                                doc.setTextColor(0, 0, 0); // Texto negro para contraste
                                doc.setFont(undefined, 'bold'); // Texto en negrita
                                doc.text(data.cell.text, data.cell.x + data.cell.padding('left'), data.cell.y + data.cell.padding('top'));
                            }
                        }
                    },
                    didDrawPage: function (data) {
                        let str = "Página " + doc.internal.getNumberOfPages();
                        doc.setFontSize(8);
                        doc.setTextColor(150);
                        doc.text(str, data.settings.margin.left, doc.internal.pageSize.height - 10);
                    }
                });

                yOffset = doc.autoTable.previous.finalY;

                let studentTotalScore = 0;
                let hasEvaluatedAspects = false;
                currentRubric.aspects.forEach(aspect => {
                    const assignedLevel = evaluations[evaluationKey] ? evaluations[evaluationKey][aspect] || 'No Evaluado' : 'No Evaluado';
                    const scoreForAspect = currentRubric.levelScores[assignedLevel] || 0;
                    if (assignedLevel !== 'No Evaluado') {
                        studentTotalScore += scoreForAspect;
                        hasEvaluatedAspects = true;
                    }
                });

                let maxPossibleScore = 0;
                currentRubric.aspects.forEach(aspect => {
                    let maxAspectScore = 0;
                    currentRubric.levels.forEach(level => {
                        const score = currentRubric.levelScores[level] || 0;
                        if (score > maxAspectScore) {
                            maxAspectScore = score;
                        }
                    });
                    maxPossibleScore += maxAspectScore;
                });

                const studentAverageScore = hasEvaluatedAspects ? (studentTotalScore / currentRubric.aspects.length).toFixed(1) : 'N/A';
                const performanceLevel = getPerformanceLevel(parseFloat(studentAverageScore));

                doc.setFontSize(10);
                doc.setTextColor(0, 100, 0);
                doc.text(`Puntaje Final: ${studentTotalScore} / ${maxPossibleScore} pts`, margin, yOffset + 5);
                doc.text(`Promedio por Aspecto: ${studentAverageScore}`, margin, yOffset + 10);
                doc.text(`Nivel de Desempeño: ${performanceLevel.level}`, margin, yOffset + 15);
            } 

            doc.deletePage(1); // Eliminar la primera página en blanco
            doc.save(`reporte_general_grupo_${currentGroupName.replace(/[^a-zA-Z0-9]/g, '_')}.pdf`); 
            showMessage(reportMessageBox, "¡Reporte PDF generado y descargado!", 'success'); 
        }); 

        exportCsvBtn.addEventListener('click', () => { 
            if (currentStudents.length === 0) { 
                showMessage(reportMessageBox, "No hay estudiantes en el grupo actual para exportar.", 'error'); 
                return; 
            } 
            if (!currentRubric) { 
                showMessage(reportMessageBox, "No hay una rúbrica seleccionada para exportar.", 'error'); 
                return; 
            } 

            const currentGroupName = groupSelect.value; 
            let csvContent = "data:text/csv;charset=utf-8,"; 
            
            // Encabezados 
            const headers = ["Estudiante", ...currentRubric.aspects, "Puntaje Total", "Promedio", "Nivel de Desempeño"]; 
            csvContent += headers.map(h => `"${h}"`).join(",") + "\r\n"; 

            currentStudents.forEach(student => { 
                const evaluationKey = `${currentGroupName}_${student}`; 
                let rowData = [student]; 
                let totalScore = 0; 
                let evaluatedAspectsCount = 0; 

                currentRubric.aspects.forEach(aspect => { 
                    const assignedLevel = evaluations[evaluationKey] ? evaluations[evaluationKey][aspect] || '' : ''; 
                    const scoreForAspect = assignedLevel ? currentRubric.levelScores[assignedLevel] || 0 : 0; 
                    
                    if (assignedLevel) { 
                        totalScore += scoreForAspect; 
                        evaluatedAspectsCount++; 
                    } 
                    
                    rowData.push(assignedLevel); 
                }); 

                const averageScore = evaluatedAspectsCount > 0 ? (totalScore / currentRubric.aspects.length).toFixed(1) : 0; 
                const performanceLevel = getPerformanceLevel(parseFloat(averageScore)); 
                
                rowData.push(totalScore); 
                rowData.push(averageScore); 
                rowData.push(performanceLevel.level); 
                
                csvContent += rowData.map(item => `"${String(item).replace(/"/g, '""')}"`).join(",") + "\r\n"; // Escapar comillas dobles
            }); 

            const encodedUri = encodeURI(csvContent); 
            const link = document.createElement("a"); 
            link.setAttribute("href", encodedUri); 
            link.setAttribute("download", `evaluaciones_${currentGroupName.replace(/[^a-zA-Z0-9]/g, '_')}.csv`); 
            document.body.appendChild(link); 
            link.click(); 
            document.body.removeChild(link); 
            
            showMessage(reportMessageBox, "¡Datos exportados a CSV correctamente!", 'success'); 
        }); 

        // --- Funciones de Modal Personalizado (Reemplazo de window.confirm) ---
        /**
         * Crea y muestra un modal de confirmación personalizado.
         * @param {string} message - El mensaje a mostrar en el modal.
         * @returns {Promise<boolean>} Una promesa que se resuelve a true si el usuario confirma, false si cancela.
         */
        function createCustomConfirm(message) {
            return new Promise((resolve) => {
                const modalOverlay = document.createElement('div');
                modalOverlay.classList.add('fixed', 'inset-0', 'bg-gray-900', 'bg-opacity-75', 'flex', 'items-center', 'justify-center', 'z-50', 'p-4');
                modalOverlay.innerHTML = `
                    <div class="bg-white rounded-lg p-6 shadow-xl max-w-sm w-full transform transition-all scale-100 opacity-100">
                        <p class="text-gray-800 text-lg mb-6 text-center">${message}</p>
                        <div class="flex justify-end gap-4">
                            <button id="modal-cancel-btn" class="bg-gray-300 text-gray-800 font-semibold py-2 px-4 rounded-lg hover:bg-gray-400 focus:outline-none focus:ring-2 focus:ring-gray-500">
                                Cancelar
                            </button>
                            <button id="modal-confirm-btn" class="bg-red-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-red-700">
                                Confirmar
                            </button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modalOverlay);

                const closeModal = (result) => {
                    modalOverlay.classList.add('opacity-0', 'scale-95');
                    modalOverlay.addEventListener('transitionend', () => {
                        modalOverlay.remove();
                    });
                    resolve(result);
                };

                document.getElementById('modal-confirm-btn').addEventListener('click', () => closeModal(true));
                document.getElementById('modal-cancel-btn').addEventListener('click', () => closeModal(false));
                modalOverlay.addEventListener('click', (e) => {
                    if (e.target === modalOverlay) closeModal(false); // Clic fuera del modal
                });
            });
        }

        // --- Inicialización --- 
        // Cargar los datos al cargar la ventana
        window.onload = loadData;

    </script> 
</body> 
</html>
