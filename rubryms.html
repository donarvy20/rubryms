<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Evaluador de Estudiantes por R√∫brica</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.14/jspdf.plugin.autotable.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
            position: relative; /* Needed for hamburger menu positioning */
        }
        .container {
            background-color: #ffffff;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            padding: 30px;
            max-width: 1000px;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 20px;
            transition: all 0.3s ease-in-out;
            z-index: 1; /* Ensure container is above other elements */
        }
        textarea {
            min-height: 150px;
            resize: vertical;
        }
        button {
            transition: background-color 0.3s ease, transform 0.2s ease;
        }
        button:hover {
            transform: translateY(-2px);
        }
        button:active {
            transform: translateY(0);
        }
        .message-box {
            background-color: #e0f2f7;
            color: #0288d1;
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            text-align: center;
            display: none;
        }
        .message-box.error {
            background-color: #ffebee;
            color: #d32f2f;
        }
        .message-box.success {
            background-color: #e8f5e9;
            color: #388e3c;
        }
        .performance-level {
            font-weight: bold;
            padding: 3px 8px;
            border-radius: 4px;
            margin-left: 10px;
        }
        .performance-level.previous {
            background-color: #ffcccc;
            color: #cc0000;
        }
        .performance-level.beginning {
            background-color: #ffebcc;
            color: #cc7a00;
        }
        .performance-level.process {
            background-color: #ffffcc;
            color: #999900;
        }
        .performance-level.achieved {
            background-color: #e6ffe6;
            color: #006600;
        }
        .performance-level.outstanding {
            background-color: #e6f7ff;
            color: #0066cc;
        }
        .rubric-preview {
            max-height: 500px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
            margin-top: 10px;
            background-color: #f9f9f9;
        }
        .rubric-preview table {
            width: 100%;
            border-collapse: collapse;
        }
        .rubric-preview th, .rubric-preview td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        .rubric-preview th {
            background-color: #f2f2f2;
        }
        .rubric-preview textarea {
            min-height: 80px;
            width: 100%;
        }
        .rubric-preview input[type="text"], .rubric-preview input[type="number"] {
            width: 100%;
            padding: 4px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        /* Styles for hamburger menu */
        .hamburger-menu {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000; /* Ensure it's on top */
            cursor: pointer;
            display: flex;
            flex-direction: column;
            gap: 6px;
            width: 30px;
            height: 24px;
            padding: 5px;
            border-radius: 8px;
            background-color: rgba(255, 255, 255, 0.8);
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: all 0.3s ease-in-out;
        }
        .hamburger-menu span {
            display: block;
            width: 100%;
            height: 3px;
            background-color: #333;
            border-radius: 2px;
            transition: all 0.3s ease-in-out;
        }
        /* Rotation for close icon */
        .hamburger-menu.open span:nth-child(1) {
            transform: rotate(45deg) translate(5px, 5px);
        }
        .hamburger-menu.open span:nth-child(2) {
            opacity: 0;
        }
        .hamburger-menu.open span:nth-child(3) {
            transform: rotate(-45deg) translate(5px, -5px);
        }

        .sidebar {
            position: fixed;
            top: 0;
            left: -250px; /* Hidden by default */
            width: 250px;
            height: 100%;
            background-color: #334155; /* slate-700 */
            color: white;
            padding: 20px;
            box-shadow: 2px 0 5px rgba(0,0,0,0.3);
            transition: left 0.3s ease-in-out;
            z-index: 999; /* Ensure it's above content but below hamburger icon */
            display: flex;
            flex-direction: column;
        }
        .sidebar.open {
            left: 0;
        }
        .sidebar a {
            padding: 10px 15px;
            margin-bottom: 10px;
            color: white;
            text-decoration: none;
            border-radius: 8px;
            transition: background-color 0.2s ease;
        }
        .sidebar a:hover {
            background-color: #475569; /* slate-600 */
        }
        .sidebar .close-btn {
            align-self: flex-end;
            background: none;
            border: none;
            font-size: 24px;
            color: white;
            cursor: pointer;
            margin-bottom: 20px;
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }
        .modal-content {
            background-color: #ffffff;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            text-align: center;
            max-width: 400px;
            width: 90%;
            transform: translateY(-20px);
            animation: fadeIn 0.3s ease-out forwards;
        }
        @keyframes fadeIn {
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        .modal-content p {
            margin-bottom: 20px;
            font-size: 1.1em;
            color: #333;
        }
        .modal-content button {
            margin: 0 10px;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 600;
        }

        /* Responsive adjustments for overall layout */
        @media (max-width: 768px) {
            .container {
                padding-top: 80px; /* Adjust for fixed hamburger */
            }
            .hamburger-menu {
                top: 10px;
                left: 10px;
            }
        }
    </style>
</head>
<body>
    <!-- Hamburger Menu Icon -->
    <div class="hamburger-menu" id="hamburger-menu">
        <span></span>
        <span></span>
        <span></span>
    </div>

    <!-- Sidebar Navigation -->
    <aside class="sidebar" id="sidebar">
        <button class="close-btn" id="close-sidebar-btn">&times;</button>
        <a href="#" id="nav-add-students">üìù Estudiantes</a>
        <a href="#" id="nav-rubric-config">üìö R√∫bricas</a>
        <a href="#" id="nav-evaluation">üéØ Evaluaci√≥n</a>
        <a href="#" id="nav-report">üìä Reportes</a>
        <a href="#" id="nav-new-evaluation">üÜï Nueva Evaluaci√≥n</a>
    </aside>

    <div class="container">
        <h1 class="text-3xl md:text-4xl font-bold text-center text-gray-800 mb-6">Evaluador de Estudiantes</h1>

        <!-- Secci√≥n de A√±adir Estudiantes -->
        <div id="add-students-section" class="bg-blue-50 p-6 rounded-xl border border-blue-200">
            <h2 class="text-2xl font-semibold text-gray-700 mb-4 text-center">1. Agregar y Gestionar Estudiantes</h2>
            
            <div class="mb-4">
                <label for="group-name-input" class="block text-gray-700 font-medium mb-2">Nombre del Nuevo Grupo de Estudiantes (opcional):</label>
                <input
                    type="text"
                    id="group-name-input"
                    class="w-full p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 transition duration-200"
                    placeholder="Ej: Grupo A, Ciencias Sociales"
                />
            </div>

            <p class="text-gray-600 mb-2 text-center">Pega aqu√≠ la lista de nombres de tus estudiantes (uno por l√≠nea).</p>
            <textarea
                id="student-list-input"
                class="w-full p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 transition duration-200"
                placeholder="Ejemplo:&#10;Juan P√©rez&#10;Mar√≠a Garc√≠a&#10;Carlos L√≥pez"
            ></textarea>
            <button
                id="add-students-btn"
                class="w-full bg-blue-600 text-white font-semibold py-3 px-6 mt-4 rounded-xl shadow-md hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-300"
            >
                Guardar Lista de Estudiantes
            </button>
            <div id="student-message-box" class="message-box"></div>

            <div class="mt-6 border-t pt-4 border-gray-200">
                <h3 class="text-xl font-semibold text-gray-700 mb-4 text-center">Seleccionar Grupo para Evaluaci√≥n</h3>
                <p class="text-gray-600 mb-2 text-center">O elige un grupo existente para evaluar:</p>
                <select id="group-select" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 transition duration-200">
                    <option value="">-- Seleccionar Grupo --</option>
                </select>
                <button
                    id="select-group-btn"
                    class="w-full bg-indigo-600 text-white font-semibold py-3 px-6 mt-4 rounded-xl shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-4 focus:ring-indigo-300"
                >
                    Cargar Grupo Seleccionado y Continuar
                </button>
                <button
                    id="delete-group-btn"
                    class="w-full bg-red-500 text-white font-semibold py-3 px-6 mt-2 rounded-xl shadow-md hover:bg-red-600 focus:outline-none focus:ring-4 focus:ring-red-300"
                >
                    Eliminar Grupo Seleccionado
                </button>
            </div>
        </div>

        <!-- Secci√≥n de Configuraci√≥n de R√∫brica -->
        <div id="rubric-config-section" class="bg-green-50 p-6 rounded-xl border border-green-200 hidden">
            <h2 class="text-2xl font-semibold text-gray-700 mb-4 text-center">2. Configurar R√∫brica</h2>
            
            <div class="mb-6">
                <h3 class="text-xl font-semibold text-gray-700 mb-4">Seleccionar R√∫brica Existente</h3>
                <select id="rubric-select" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-green-500 focus:border-green-500 transition duration-200">
                    <option value="">-- Seleccionar R√∫brica --</option>
                </select>
                <button
                    id="load-rubric-btn"
                    class="w-full bg-indigo-600 text-white font-semibold py-3 px-6 mt-4 rounded-xl shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-4 focus:ring-indigo-300"
                >
                    Cargar R√∫brica Seleccionada y Empezar Evaluaci√≥n
                </button>
                <button
                    id="delete-rubric-btn"
                    class="w-full bg-red-500 text-white font-semibold py-2 px-4 mt-2 rounded-lg shadow-md hover:bg-red-600 focus:outline-none focus:ring-4 focus:ring-red-300"
                >
                    Eliminar R√∫brica Seleccionada
                </button>
            </div>

            <div class="mb-6">
                <h3 class="text-xl font-semibold text-gray-700 mb-4">Importar Nueva R√∫brica desde CSV</h3>
                <p class="text-gray-600 mb-2">Formato requerido: Primera fila son los niveles de desempe√±o, primera columna son los aspectos a evaluar, celdas son los descriptores.</p>
                <label for="rubric-name-input" class="block text-gray-700 font-medium mb-2">Nombre de la R√∫brica:</label>
                <input
                    type="text"
                    id="rubric-name-input"
                    class="w-full p-3 border border-gray-300 rounded-lg focus:ring-green-500 focus:border-green-500 transition duration-200"
                    placeholder="Ej: R√∫brica de Presentaciones Orales"
                />
                <textarea
                    id="rubric-csv-input"
                    class="w-full p-3 border border-gray-300 rounded-lg focus:ring-green-500 focus:border-green-500 transition duration-200 mt-2"
                    placeholder='Pega aqu√≠ el contenido CSV de la r√∫brica. Ejemplo:&#10;,Destacado,Logrado,En Proceso,En Inicio&#10;"Coherencia","Descriptor con, coma","Descriptor 2","Descriptor 3","Descriptor 4"&#10;"Claridad","Descriptor 1","Descriptor 2","Descriptor, con coma","Descriptor 4"'
                    rows="8"
                ></textarea>
                <div id="rubric-preview" class="rubric-preview hidden"></div>
                <button
                    id="preview-rubric-btn"
                    class="w-full bg-blue-500 text-white font-semibold py-2 px-4 mt-2 rounded-lg shadow-md hover:bg-blue-600 focus:outline-none focus:ring-4 focus:ring-blue-300"
                >
                    Previsualizar y Editar R√∫brica
                </button>
                <!-- Este bot√≥n se mostrar√° despu√©s de la previsualizaci√≥n y confirmaci√≥n de edici√≥n -->
                <!-- The original save-rubric-btn is now handled by confirm-save-rubric-btn within the preview -->
            </div>
            <div id="rubric-config-message-box" class="message-box"></div>
        </div>

        <div id="evaluation-section" class="bg-yellow-50 p-6 rounded-xl border border-yellow-200 hidden">
            <h2 class="text-2xl font-semibold text-gray-700 mb-4 text-center">3. Evaluaci√≥n de Estudiantes</h2>
            <div class="text-center mb-4">
                <p class="text-lg text-gray-800 font-semibold">Estudiante Actual: <span id="current-student-name" class="text-blue-600"></span></p>
                <p class="text-gray-600 text-sm">Estudiante <span id="student-index">1</span> de <span id="total-students">0</span></p>
            </div>
            <div id="student-rubric-display" class="overflow-x-auto">
                <!-- Rubric evaluation table will be rendered here -->
            </div>
            <div class="flex flex-col sm:flex-row justify-center gap-4 mt-6">
                <button
                    id="prev-student-btn"
                    class="flex-1 bg-gray-400 text-white font-semibold py-3 px-6 rounded-xl shadow-md hover:bg-gray-500 focus:outline-none focus:ring-4 focus:ring-gray-300"
                >
                    Anterior
                </button>
                <button
                    id="next-student-btn"
                    class="flex-1 bg-blue-600 text-white font-semibold py-3 px-6 rounded-xl shadow-md hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-300"
                >
                    Siguiente Estudiante
                </button>
                <button
                    id="finish-evaluation-btn"
                    class="flex-1 bg-indigo-600 text-white font-semibold py-3 px-6 rounded-xl shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-4 focus:ring-indigo-300 hidden"
                >
                    Finalizar Evaluaci√≥n y Exportar
                </button>
            </div>
            <div id="evaluation-message-box" class="message-box"></div>
        </div>

        <div id="report-section" class="bg-red-50 p-6 rounded-xl border border-red-200 hidden">
            <h2 class="text-2xl font-semibold text-gray-700 mb-4 text-center">4. Reporte y Exportaci√≥n</h2>
            <p class="text-gray-600 mb-4 text-center">Haz clic para generar el reporte de todas las evaluaciones.</p>
            <div class="flex flex-col sm:flex-row justify-center gap-4 mt-6">
                <button
                    id="export-pdf-btn"
                    class="flex-1 bg-red-600 text-white font-semibold py-3 px-6 rounded-xl shadow-md hover:bg-red-700 focus:outline-none focus:ring-4 focus:ring-red-300"
                >
                    Exportar Reporte General a PDF
                </button>
                <button
                    id="export-individual-rubrics-btn"
                    class="flex-1 bg-teal-600 text-white font-semibold py-3 px-6 rounded-xl shadow-md hover:bg-teal-700 focus:outline-none focus:ring-4 focus:ring-teal-300"
                >
                    Exportar R√∫bricas Individuales a PDF
                </button>
                <button
                    id="export-csv-btn"
                    class="flex-1 bg-green-600 text-white font-semibold py-3 px-6 rounded-xl shadow-md hover:bg-green-700 focus:outline-none focus:ring-4 focus:ring-green-300"
                >
                    Exportar a CSV
                </button>
            </div>
            <div class="flex flex-col sm:flex-row justify-center gap-4 mt-4">
                <button
                    id="back-to-evaluation-btn"
                    class="flex-1 bg-gray-600 text-white font-semibold py-3 px-6 rounded-xl shadow-md hover:bg-gray-700 focus:outline-none focus:ring-4 focus:ring-gray-300"
                >
                    Atr√°s (Modificar Evaluaci√≥n)
                </button>
                <button
                    id="new-evaluation-btn"
                    class="flex-1 bg-blue-600 text-white font-semibold py-3 px-6 rounded-xl shadow-md hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-300"
                >
                    Nueva Evaluaci√≥n
                </button>
            </div>
            <div id="report-message-box" class="message-box"></div>
        </div>

    </div>

    <!-- Custom Confirmation Modal -->
    <div id="confirm-modal-overlay" class="modal-overlay hidden">
        <div class="modal-content">
            <p id="confirm-modal-message"></p>
            <button id="confirm-modal-ok" class="bg-blue-500 text-white hover:bg-blue-600">Aceptar</button>
            <button id="confirm-modal-cancel" class="bg-gray-300 text-gray-800 hover:bg-gray-400">Cancelar</button>
        </div>
    </div>

    <script>
        // Get DOM elements
        const hamburgerMenu = document.getElementById('hamburger-menu');
        const sidebar = document.getElementById('sidebar');
        const closeSidebarBtn = document.getElementById('close-sidebar-btn');

        const addStudentsSection = document.getElementById('add-students-section');
        const groupNameInput = document.getElementById('group-name-input');
        const studentListInput = document.getElementById('student-list-input');
        const addStudentsBtn = document.getElementById('add-students-btn');
        const groupSelect = document.getElementById('group-select');
        const selectGroupBtn = document.getElementById('select-group-btn');
        const deleteGroupBtn = document.getElementById('delete-group-btn');
        const studentMessageBox = document.getElementById('student-message-box');

        const rubricConfigSection = document.getElementById('rubric-config-section');
        const rubricSelect = document.getElementById('rubric-select');
        const loadRubricBtn = document.getElementById('load-rubric-btn'); // New button
        const deleteRubricBtn = document.getElementById('delete-rubric-btn');
        const rubricNameInput = document.getElementById('rubric-name-input');
        const rubricCsvInput = document.getElementById('rubric-csv-input');
        const rubricPreview = document.getElementById('rubric-preview');
        const previewRubricBtn = document.getElementById('preview-rubric-btn');
        const rubricConfigMessageBox = document.getElementById('rubric-config-message-box');

        const evaluationSection = document.getElementById('evaluation-section');
        const currentStudentName = document.getElementById('current-student-name');
        const studentIndexSpan = document.getElementById('student-index');
        const totalStudentsSpan = document.getElementById('total-students');
        const studentRubricDisplay = document.getElementById('student-rubric-display');
        const prevStudentBtn = document.getElementById('prev-student-btn');
        const nextStudentBtn = document.getElementById('next-student-btn');
        const finishEvaluationBtn = document.getElementById('finish-evaluation-btn');
        const evaluationMessageBox = document.getElementById('evaluation-message-box');

        const reportSection = document.getElementById('report-section');
        const exportPdfBtn = document.getElementById('export-pdf-btn');
        const exportIndividualRubricsBtn = document.getElementById('export-individual-rubrics-btn');
        const exportCsvBtn = document.getElementById('export-csv-btn');
        const backToEvaluationBtn = document.getElementById('back-to-evaluation-btn');
        const newEvaluationBtn = document.getElementById('new-evaluation-btn'); // Renamed from newRubricBtn
        const reportMessageBox = document.getElementById('report-message-box');

        const navAddStudents = document.getElementById('nav-add-students');
        const navRubricConfig = document.getElementById('nav-rubric-config');
        const navEvaluation = document.getElementById('nav-evaluation');
        const navReport = document.getElementById('nav-report');
        const navNewEvaluation = document.getElementById('nav-new-evaluation');

        // Custom Confirmation Modal elements
        const confirmModalOverlay = document.getElementById('confirm-modal-overlay');
        const confirmModalMessage = document.getElementById('confirm-modal-message');
        const confirmModalOk = document.getElementById('confirm-modal-ok');
        const confirmModalCancel = document.getElementById('confirm-modal-cancel');


        // Global application variables
        let studentGroups = {};
        let currentStudents = [];
        let currentStudentIndex = 0;
        let savedRubrics = {};
        let currentRubric = null;
        let evaluations = {};
        let temporaryRubric = null; // Used for editing a rubric before final save

        // --- Utility Functions ---

        /**
         * Displays a message in a designated message box.
         * @param {HTMLElement} boxElement - The DOM element to display the message in.
         * @param {string} message - The message text.
         * @param {string} type - 'success', 'error', or empty for default.
         */
        function showMessage(boxElement, message, type = '') {
            boxElement.textContent = message;
            boxElement.className = 'message-box'; // Reset classes
            if (type) {
                boxElement.classList.add(type);
            }
            boxElement.style.display = 'block';
            setTimeout(() => {
                boxElement.style.display = 'none';
            }, 5000);
        }

        /**
         * Custom confirmation modal instead of window.confirm.
         * @param {string} message - The message to display.
         * @returns {Promise<boolean>} Resolves true if confirmed, false if cancelled.
         */
        function showConfirmModal(message) {
            return new Promise((resolve) => {
                confirmModalMessage.textContent = message;
                confirmModalOverlay.classList.remove('hidden');

                const handleOk = () => {
                    confirmModalOverlay.classList.add('hidden');
                    confirmModalOk.removeEventListener('click', handleOk);
                    confirmModalCancel.removeEventListener('click', handleCancel);
                    resolve(true);
                };

                const handleCancel = () => {
                    confirmModalOverlay.classList.add('hidden');
                    confirmModalOk.removeEventListener('click', handleOk);
                    confirmModalCancel.removeEventListener('click', handleCancel);
                    resolve(false);
                };

                confirmModalOk.addEventListener('click', handleOk);
                confirmModalCancel.addEventListener('click', handleCancel);
            });
        }


        /**
         * Parses CSV text, handling commas within quoted fields.
         * @param {string} text - The CSV string.
         * @returns {Array<Array<string>>} Parsed 2D array of strings.
         */
        function parseCSV(text) {
            const lines = text.split('\n').filter(line => line.trim() !== '');
            const result = [];
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const current = [];
                let inQuotes = false;
                let buffer = '';
                
                for (let j = 0; j < line.length; j++) {
                    const char = line[j];
                    
                    if (char === '"') {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        current.push(buffer.trim());
                        buffer = '';
                    } else {
                        buffer += char;
                    }
                }
                
                current.push(buffer.trim());
                result.push(current);
            }
            
            return result;
        }

        /**
         * Loads all saved data from localStorage into global variables.
         */
        function loadData() {
            try {
                const storedStudentGroups = localStorage.getItem('studentGroups');
                if (storedStudentGroups) {
                    studentGroups = JSON.parse(storedStudentGroups);
                    renderGroupSelect();
                }

                const storedRubrics = localStorage.getItem('savedRubrics');
                if (storedRubrics) {
                    savedRubrics = JSON.parse(storedRubrics);
                    renderRubricSelect();
                }

                const storedCurrentGroup = localStorage.getItem('currentSelectedGroup');
                if(storedCurrentGroup && studentGroups[storedCurrentGroup]) {
                    currentStudents = studentGroups[storedCurrentGroup];
                    groupSelect.value = storedCurrentGroup;
                }

                const storedCurrentRubric = localStorage.getItem('currentRubric');
                if (storedCurrentRubric) {
                    currentRubric = JSON.parse(storedCurrentRubric);
                }

                const storedEvaluations = localStorage.getItem('evaluations');
                if (storedEvaluations) {
                    evaluations = JSON.parse(storedEvaluations);
                }

                // Initial UI state based on loaded data
                if (currentStudents.length > 0) {
                    addStudentsSection.classList.add('hidden');
                    if (currentRubric) {
                        rubricConfigSection.classList.add('hidden');
                        evaluationSection.classList.remove('hidden');
                        renderStudentEvaluation();
                    } else {
                        rubricConfigSection.classList.remove('hidden');
                        // Show message to select/import a rubric
                        showMessage(rubricConfigMessageBox, "Por favor, selecciona una r√∫brica existente o importa una nueva para empezar la evaluaci√≥n.", 'info');
                    }
                } else {
                    showSection('add-students-section'); // Start at student management if no group is loaded
                }

            } catch (e) {
                console.error("Error al cargar datos de localStorage:", e);
                showMessage(studentMessageBox, "Error al cargar datos guardados. Los datos pueden estar corruptos.", 'error');
            }
        }

        /**
         * Saves all current application data to localStorage.
         */
        function saveData() {
            try {
                localStorage.setItem('studentGroups', JSON.stringify(studentGroups));
                localStorage.setItem('savedRubrics', JSON.stringify(savedRubrics));
                localStorage.setItem('evaluations', JSON.stringify(evaluations));
                localStorage.setItem('currentSelectedGroup', groupSelect.value);
                if (currentRubric) {
                    localStorage.setItem('currentRubric', JSON.stringify(currentRubric));
                }
            } catch (e) {
                console.error("Error al guardar datos en localStorage:", e);
                showMessage(studentMessageBox, "No se pudieron guardar los datos. Verifique el espacio disponible en su navegador.", 'error');
            }
        }

        /**
         * Resets the current evaluation state, but keeps student groups and saved rubrics.
         */
        function resetApp() {
            localStorage.removeItem('currentRubric');
            localStorage.removeItem('evaluations');

            currentRubric = null;
            evaluations = {};
            currentStudentIndex = 0; // Reset student index too

            // Show appropriate section after reset
            if (currentStudents.length > 0) {
                showSection('rubric-config-section');
                showMessage(rubricConfigMessageBox, "La evaluaci√≥n ha sido reiniciada. Tus grupos y r√∫bricas permanecen guardados.", 'success');
            } else {
                showSection('add-students-section');
                showMessage(studentMessageBox, "La evaluaci√≥n ha sido reiniciada. Por favor, selecciona o agrega un grupo de estudiantes.", 'success');
            }
            
            // Clear rubric inputs
            rubricNameInput.value = '';
            rubricCsvInput.value = '';
            rubricPreview.classList.add('hidden');
        }

        // --- Navigation Logic (Hamburger Menu) ---

        /**
         * Toggles the visibility of the sidebar navigation.
         */
        function toggleSidebar() {
            sidebar.classList.toggle('open');
            hamburgerMenu.classList.toggle('open');
        }

        /**
         * Hides all main content sections and shows the specified one.
         * @param {string} sectionId - The ID of the section to show.
         */
        function showSection(sectionId) {
            const sections = [addStudentsSection, rubricConfigSection, evaluationSection, reportSection];
            sections.forEach(section => {
                if (section.id === sectionId) {
                    section.classList.remove('hidden');
                } else {
                    section.classList.add('hidden');
                }
            });
            sidebar.classList.remove('open'); // Close sidebar after navigation
            hamburgerMenu.classList.remove('open'); // Reset hamburger icon
        }

        // Event listeners for hamburger menu and sidebar navigation
        hamburgerMenu.addEventListener('click', toggleSidebar);
        closeSidebarBtn.addEventListener('click', toggleSidebar);

        navAddStudents.addEventListener('click', (e) => {
            e.preventDefault();
            showSection('add-students-section');
        });
        navRubricConfig.addEventListener('click', (e) => {
            e.preventDefault();
            showSection('rubric-config-section');
        });
        navEvaluation.addEventListener('click', (e) => {
            e.preventDefault();
            if (currentStudents.length > 0 && currentRubric) {
                renderStudentEvaluation();
                showSection('evaluation-section');
            } else {
                showMessage(evaluationMessageBox, "Necesitas cargar un grupo de estudiantes y una r√∫brica antes de evaluar.", 'error');
                showSection('add-students-section'); // Go back to student section if no students/rubric
            }
        });
        navReport.addEventListener('click', (e) => {
            e.preventDefault();
            showSection('report-section');
        });
        navNewEvaluation.addEventListener('click', async (e) => {
            e.preventDefault();
            const confirm = await showConfirmModal("¬øEst√°s seguro de que quieres iniciar una nueva evaluaci√≥n? Esto borrar√° las evaluaciones actuales pero mantendr√° tus grupos y r√∫bricas guardadas.");
            if (confirm) {
                resetApp();
            }
        });


        // --- Student Management Logic ---

        /**
         * Populates the student group selection dropdown.
         */
        function renderGroupSelect() {
            groupSelect.innerHTML = '<option value="">-- Seleccionar Grupo --</option>';
            for (const groupName in studentGroups) {
                const option = document.createElement('option');
                option.value = groupName;
                option.textContent = groupName;
                groupSelect.appendChild(option);
            }
            // Retain selected value if it still exists
            const currentSelectedGroup = localStorage.getItem('currentSelectedGroup');
            if (currentSelectedGroup && studentGroups[currentSelectedGroup]) {
                groupSelect.value = currentSelectedGroup;
            } else {
                groupSelect.value = ""; // Reset if not found
            }
        }

        addStudentsBtn.addEventListener('click', () => {
            const rawList = studentListInput.value.trim();
            let groupName = groupNameInput.value.trim();
            const selectedGroupOption = groupSelect.value; // Get value from selected option

            if (!rawList) {
                showMessage(studentMessageBox, "Por favor, introduce la lista de estudiantes.", 'error');
                return;
            }

            // Remove duplicates and empty lines
            const newStudents = rawList.split('\n')
                                        .map(name => name.trim())
                                        .filter(name => name !== '')
                                        .filter((name, index, self) => self.indexOf(name) === index); // Unique names

            if (newStudents.length === 0) {
                showMessage(studentMessageBox, "No se encontraron nombres de estudiantes v√°lidos en la lista.", 'error');
                return;
            }

            let targetGroupName;
            let actionMessage = "";

            if (groupName) { // User provided a new group name or wants to overwrite/create with this name
                targetGroupName = groupName;
                studentGroups[targetGroupName] = newStudents;
                actionMessage = `¬°Grupo "${targetGroupName}" con ${newStudents.length} estudiantes guardado (o actualizado)!`;
            } else if (selectedGroupOption) { // User selected an existing group from the dropdown
                targetGroupName = selectedGroupOption;
                const existingStudents = studentGroups[targetGroupName] || [];
                // Combine existing and new students, ensuring uniqueness
                const combinedStudents = [...new Set([...existingStudents, ...newStudents])];
                studentGroups[targetGroupName] = combinedStudents;
                actionMessage = `¬°${newStudents.length} estudiantes a√±adidos al grupo "${targetGroupName}"! Total: ${combinedStudents.length} estudiantes.`;
            } else { // No group name provided and no group selected
                targetGroupName = `Grupo - ${new Date().toLocaleDateString('es-ES')}`;
                let counter = 1;
                while(studentGroups[targetGroupName]) { // Prevent duplicate auto-generated names
                    targetGroupName = `Grupo - ${new Date().toLocaleDateString('es-ES')} (${counter})`;
                    counter++;
                }
                studentGroups[targetGroupName] = newStudents;
                actionMessage = `¬°Nuevo grupo an√≥nimo "${targetGroupName}" con ${newStudents.length} estudiantes creado!`;
            }

            currentStudents = studentGroups[targetGroupName];
            renderGroupSelect();
            groupSelect.value = targetGroupName; // Set the dropdown to the newly saved/updated group
            saveData();
            showMessage(studentMessageBox, actionMessage, 'success');

            groupNameInput.value = ''; // Clear input fields
            studentListInput.value = '';
        });

        selectGroupBtn.addEventListener('click', () => {
            const selectedGroup = groupSelect.value;
            if (!selectedGroup) {
                showMessage(studentMessageBox, "Por favor, selecciona un grupo de estudiantes.", 'error');
                return;
            }

            currentStudents = studentGroups[selectedGroup];
            saveData();
            showMessage(studentMessageBox, `¬°Grupo "${selectedGroup}" cargado para evaluaci√≥n!`, 'success');

            showSection('rubric-config-section');
            currentStudentIndex = 0; // Reset index for new evaluation session
        });

        deleteGroupBtn.addEventListener('click', async () => {
            const selectedGroup = groupSelect.value;
            if (!selectedGroup) {
                showMessage(studentMessageBox, "Por favor, selecciona un grupo para eliminar.", 'error');
                return;
            }

            const confirmDelete = await showConfirmModal(`¬øEst√°s seguro de que quieres eliminar el grupo "${selectedGroup}"? Ten en cuenta que esto NO eliminar√° las evaluaciones asociadas a este grupo si ya se han realizado. Para borrar evaluaciones individuales, necesitar√≠as reiniciar la r√∫brica.`);
            if (confirmDelete) {
                delete studentGroups[selectedGroup];
                if (localStorage.getItem('currentSelectedGroup') === selectedGroup) {
                    localStorage.removeItem('currentSelectedGroup');
                    currentStudents = []; // Clear current students if the deleted group was active
                }
                renderGroupSelect();
                saveData();
                showMessage(studentMessageBox, `Grupo "${selectedGroup}" eliminado.`, 'success');
            }
        });

        // --- Rubric Configuration Logic ---

        /**
         * Populates the rubric selection dropdown.
         */
        function renderRubricSelect() {
            rubricSelect.innerHTML = '<option value="">-- Seleccionar R√∫brica --</option>';
            for (const rubricName in savedRubrics) {
                const option = document.createElement('option');
                option.value = rubricName;
                option.textContent = rubricName;
                rubricSelect.appendChild(option);
            }
            // If a current rubric is set, select it in the dropdown
            if (currentRubric && savedRubrics[currentRubric.name]) {
                rubricSelect.value = currentRubric.name;
            } else {
                rubricSelect.value = ""; // Reset if not found
            }
        }

        /**
         * Parses the CSV input into a rubric object structure.
         * @param {string} csvText - The raw CSV string from the textarea.
         * @returns {object|null} The parsed rubric object or null if parsing fails.
         */
        function parseRubricFromCSV(csvText) {
            const parsedData = parseCSV(csvText);
            if (parsedData.length < 2) {
                showMessage(rubricConfigMessageBox, "El formato del CSV no es v√°lido. Debe tener al menos 2 l√≠neas (encabezados y al menos un aspecto).", 'error');
                return null;
            }

            // Extract levels (first row, skipping the first empty cell)
            const levels = parsedData[0].slice(1).map(level => level.replace(/^"|"$/g, '').trim());
            if (levels.length === 0) {
                showMessage(rubricConfigMessageBox, "No se encontraron niveles de desempe√±o en la primera fila del CSV.", 'error');
                return null;
            }

            // Extract aspects and descriptors
            const aspects = [];
            const descriptors = {};
            const levelScores = {};
            
            // Assign default scores based on position (e.g., first level is highest score)
            // Example: if 5 levels, scores could be 5, 4, 3, 2, 1
            levels.forEach((level, index) => {
                levelScores[level] = levels.length - index;
            });

            for (let i = 1; i < parsedData.length; i++) {
                const row = parsedData[i];
                const aspect = row[0].replace(/^"|"$/g, '').trim();
                if (!aspect) continue; // Skip empty aspect rows

                aspects.push(aspect);
                descriptors[aspect] = {};

                for (let j = 1; j < row.length; j++) {
                    const level = levels[j - 1]; // Corresponding level for this column
                    if (!level) continue; // Skip if level name is missing (shouldn't happen with proper CSV)

                    descriptors[aspect][level] = row[j].replace(/^"|"$/g, '').trim();
                }
            }

            if (aspects.length === 0) {
                showMessage(rubricConfigMessageBox, "No se encontraron aspectos v√°lidos en el CSV.", 'error');
                return null;
            }

            return {
                name: rubricNameInput.value.trim() || `R√∫brica ${new Date().toLocaleDateString('es-ES')}`, // Use input name or generate one
                aspects,
                levels,
                descriptors,
                levelScores,
                generalObservations: "" // Add a field for general observations
            };
        }

        /**
         * Displays the rubric data in an editable table for preview and modification.
         * @param {object} rubricData - The rubric object to display.
         */
        function showEditableRubric(rubricData) {
            let previewHTML = '<h4 class="font-semibold mb-2">Editar R√∫brica antes de Guardar:</h4>';
            
            // Editable rubric name
            previewHTML += `
                <div class="mb-4">
                    <label for="editable-rubric-name" class="block text-gray-700 font-medium mb-2">Nombre de la R√∫brica:</label>
                    <input type="text" id="editable-rubric-name" class="w-full p-2 border border-gray-300 rounded" value="${rubricData.name}">
                </div>
            `;
            
            // Editable table structure
            previewHTML += '<table class="w-full border-collapse"><thead><tr><th class="p-2 border bg-gray-100">Aspecto</th>';
            
            // Editable level headers with scores
            rubricData.levels.forEach((level, index) => {
                previewHTML += `
                    <th class="p-2 border bg-gray-100">
                        <input type="text" class="w-full p-1 border-b border-gray-300 rounded-sm" 
                               data-level-index="${index}" onchange="updateRubricLevel(this)" value="${level}">
                        <input type="number" class="w-full p-1 mt-1 border-b border-gray-300 rounded-sm" 
                               value="${rubricData.levelScores[level]}" min="0" max="10" step="0.5"
                               data-level-index="${index}" onchange="updateRubricScore(this)">
                    </th>
                `;
            });
            previewHTML += '</tr></thead><tbody>';
            
            // Editable aspect rows and descriptors
            rubricData.aspects.forEach((aspect, aspectIndex) => {
                previewHTML += `<tr><td class="p-2 border"><input type="text" class="w-full p-1 border-b border-gray-300 rounded-sm" 
                               value="${aspect}" data-aspect-index="${aspectIndex}" onchange="updateRubricAspect(this)"></td>`;
                
                rubricData.levels.forEach((level, levelIndex) => {
                    previewHTML += `
                        <td class="p-2 border">
                            <textarea class="w-full p-1 border border-gray-300 h-20 rounded-sm" 
                                       data-aspect-index="${aspectIndex}" data-level-index="${levelIndex}"
                                       onchange="updateRubricDescriptor(this)">${rubricData.descriptors[aspect][level] || ''}</textarea>
                        </td>
                    `;
                });
                
                previewHTML += '</tr>';
            });
            
            previewHTML += '</tbody></table>';
            
            // Action buttons
            previewHTML += `
                <div class="mt-4 flex flex-col sm:flex-row justify-between gap-2">
                    <button id="cancel-edit-rubric-btn" class="flex-1 bg-gray-500 text-white px-4 py-2 rounded-lg hover:bg-gray-600 shadow-md">
                        Cancelar Edici√≥n
                    </button>
                    <button id="confirm-save-rubric-btn" class="flex-1 bg-green-600 text-white px-4 py-2 rounded-lg hover:bg-green-700 shadow-md">
                        Confirmar y Guardar R√∫brica
                    </button>
                </div>
            `;
            
            rubricPreview.innerHTML = previewHTML;
            rubricPreview.classList.remove('hidden');
            
            // Store the temporary rubric for direct manipulation during editing
            temporaryRubric = JSON.parse(JSON.stringify(rubricData)); // Deep copy to avoid modifying original until confirmed
            
            // Event listeners for the preview actions
            document.getElementById('cancel-edit-rubric-btn').addEventListener('click', () => {
                rubricPreview.classList.add('hidden');
                // saveRubricBtn.classList.add('hidden'); // This button is not used anymore in this flow
                temporaryRubric = null; // Clear temporary rubric
            });
            
            document.getElementById('confirm-save-rubric-btn').addEventListener('click', () => {
                // Get the updated name from the editable input field
                const updatedRubricName = document.getElementById('editable-rubric-name').value.trim();

                if (!updatedRubricName) {
                    showMessage(rubricConfigMessageBox, "El nombre de la r√∫brica no puede estar vac√≠o.", 'error');
                    return;
                }
                
                // If the name changed and already exists, ask for confirmation
                if (updatedRubricName !== rubricData.name && savedRubrics[updatedRubricName]) {
                    showConfirmModal(`Ya existe una r√∫brica con el nombre "${updatedRubricName}". ¬øDeseas sobrescribirla?`)
                        .then(confirm => {
                            if (confirm) {
                                finalizeRubricSave(updatedRubricName);
                            } else {
                                // Do nothing, user chose not to overwrite
                            }
                        });
                } else {
                    finalizeRubricSave(updatedRubricName);
                }
            });
        }

        /**
         * Finalizes saving the edited rubric.
         * @param {string} finalRubricName - The name to save the rubric under.
         */
        function finalizeRubricSave(finalRubricName) {
            // Remove old entry if name changed
            if (temporaryRubric.name && temporaryRubric.name !== finalRubricName && savedRubrics[temporaryRubric.name]) {
                delete savedRubrics[temporaryRubric.name];
            }

            temporaryRubric.name = finalRubricName;
            savedRubrics[temporaryRubric.name] = temporaryRubric;
            currentRubric = temporaryRubric; // Set as current
            saveData();
            renderRubricSelect(); // Update dropdown with new rubric

            rubricConfigSection.classList.add('hidden');
            evaluationSection.classList.remove('hidden');
            currentStudentIndex = 0;
            renderStudentEvaluation(); // Start evaluation with the new rubric
            
            showMessage(rubricConfigMessageBox, `¬°R√∫brica "${finalRubricName}" guardada y lista para la evaluaci√≥n!`, 'success');
            rubricPreview.classList.add('hidden'); // Hide the preview table
            rubricNameInput.value = ''; // Clear rubric input fields
            rubricCsvInput.value = '';
        }

        // Functions to update the temporary rubric during editing (global scope for inline HTML event handlers)
        window.updateRubricLevel = function(input) {
            const levelIndex = input.dataset.levelIndex;
            const newLevelName = input.value.trim();
            const oldLevelName = temporaryRubric.levels[levelIndex];
            
            if (newLevelName === "") {
                 showMessage(rubricConfigMessageBox, "El nombre de un nivel no puede estar vac√≠o.", 'error');
                 input.value = oldLevelName; // Revert
                 return;
            }

            // Update level name in the array
            temporaryRubric.levels[levelIndex] = newLevelName;
            
            // If the name changed, update the keys in levelScores and descriptors
            if (oldLevelName !== newLevelName) {
                // Update levelScores
                if (temporaryRubric.levelScores[oldLevelName] !== undefined) {
                    temporaryRubric.levelScores[newLevelName] = temporaryRubric.levelScores[oldLevelName];
                    delete temporaryRubric.levelScores[oldLevelName];
                }
                
                // Update descriptors for all aspects
                temporaryRubric.aspects.forEach(aspect => {
                    if (temporaryRubric.descriptors[aspect] && temporaryRubric.descriptors[aspect][oldLevelName] !== undefined) {
                        temporaryRubric.descriptors[aspect][newLevelName] = temporaryRubric.descriptors[aspect][oldLevelName];
                        delete temporaryRubric.descriptors[aspect][oldLevelName];
                    }
                });
            }
        };

        window.updateRubricScore = function(input) {
            const levelIndex = input.dataset.levelIndex;
            const levelName = temporaryRubric.levels[levelIndex]; // Get current name, which might have just been updated
            let score = parseFloat(input.value);

            if (isNaN(score) || score < 0) {
                showMessage(rubricConfigMessageBox, "El puntaje debe ser un n√∫mero v√°lido mayor o igual a cero.", 'error');
                input.value = temporaryRubric.levelScores[levelName] || 0; // Revert to old value or 0
                return;
            }
            temporaryRubric.levelScores[levelName] = score;
        };

        window.updateRubricAspect = function(input) {
            const aspectIndex = input.dataset.aspectIndex;
            const newAspectName = input.value.trim();
            const oldAspectName = temporaryRubric.aspects[aspectIndex];

            if (newAspectName === "") {
                showMessage(rubricConfigMessageBox, "El nombre de un aspecto no puede estar vac√≠o.", 'error');
                input.value = oldAspectName; // Revert
                return;
            }
            
            // Update aspect name in the array
            temporaryRubric.aspects[aspectIndex] = newAspectName;
            
            // If the name changed, update the key in descriptors
            if (oldAspectName !== newAspectName) {
                if (temporaryRubric.descriptors[oldAspectName] !== undefined) {
                    temporaryRubric.descriptors[newAspectName] = temporaryRubric.descriptors[oldAspectName];
                    delete temporaryRubric.descriptors[oldAspectName];
                }
            }
        };

        window.updateRubricDescriptor = function(textarea) {
            const aspectIndex = textarea.dataset.aspectIndex;
            const levelIndex = textarea.dataset.levelIndex;
            const aspectName = temporaryRubric.aspects[aspectIndex];
            const levelName = temporaryRubric.levels[levelIndex];
            
            if (temporaryRubric.descriptors[aspectName]) { // Ensure aspect exists
                temporaryRubric.descriptors[aspectName][levelName] = textarea.value.trim();
            }
        };

        previewRubricBtn.addEventListener('click', () => {
            const rubricName = rubricNameInput.value.trim();
            const csvText = rubricCsvInput.value.trim();

            if (!csvText) {
                showMessage(rubricConfigMessageBox, "Por favor, pega el contenido CSV de la r√∫brica.", 'error');
                return;
            }

            const parsedRubric = parseRubricFromCSV(csvText);
            if (parsedRubric) {
                if (rubricName) {
                    parsedRubric.name = rubricName; // Use user-provided name if available
                }
                showEditableRubric(parsedRubric);
                showMessage(rubricConfigMessageBox, "R√∫brica analizada. Puedes modificarla antes de guardar.", 'success');
            }
        });

        loadRubricBtn.addEventListener('click', () => {
            const selectedRubricName = rubricSelect.value;
            if (!selectedRubricName) {
                showMessage(rubricConfigMessageBox, "Por favor, selecciona una r√∫brica existente para cargar.", 'error');
                return;
            }
            
            if (savedRubrics[selectedRubricName]) {
                currentRubric = savedRubrics[selectedRubricName];
                saveData(); // Save the currently loaded rubric
                
                showSection('evaluation-section');
                currentStudentIndex = 0; // Reset student index for new evaluation session
                renderStudentEvaluation();
                showMessage(rubricConfigMessageBox, `R√∫brica "${selectedRubricName}" cargada para la evaluaci√≥n.`, 'success');
            } else {
                showMessage(rubricConfigMessageBox, `Error: La r√∫brica "${selectedRubricName}" no se encontr√≥.`, 'error');
            }
        });

        deleteRubricBtn.addEventListener('click', async () => {
            const selectedRubricName = rubricSelect.value;
            if (!selectedRubricName) {
                showMessage(rubricConfigMessageBox, "Por favor, selecciona una r√∫brica para eliminar.", 'error');
                return;
            }

            const confirmDelete = await showConfirmModal(`¬øEst√°s seguro de que quieres eliminar la r√∫brica "${selectedRubricName}"?`);
            if (confirmDelete) {
                delete savedRubrics[selectedRubricName];
                if (currentRubric && currentRubric.name === selectedRubricName) {
                    currentRubric = null; // Clear current rubric if it was the one deleted
                    localStorage.removeItem('currentRubric');
                }
                saveData();
                renderRubricSelect();
                showMessage(rubricConfigMessageBox, `R√∫brica "${selectedRubricName}" eliminada.`, 'success');
            }
        });

        // --- Student Evaluation Logic ---

        /**
         * Determines the performance level based on an average score.
         * @param {number} averageScore - The average score.
         * @returns {object} An object with `level` (text) and `class` (CSS class).
         */
        function getPerformanceLevel(averageScore) {
            if (averageScore >= 4.5 && averageScore <= 5) return { level: "Destacado", class: "outstanding" };
            if (averageScore >= 3.5 && averageScore < 4.5) return { level: "Logrado", class: "achieved" };
            if (averageScore >= 2.5 && averageScore < 3.5) return { level: "En proceso", class: "process" };
            if (averageScore >= 1.5 && averageScore < 2.5) return { level: "Inicio", class: "beginning" };
            if (averageScore >= 0 && averageScore < 1.5) return { level: "Previo al inicio", class: "previous" };
            return { level: "No evaluado", class: "" };
        }

        /**
         * Renders the evaluation table for the current student.
         */
        function renderStudentEvaluation() {
            if (!currentRubric || currentStudents.length === 0) {
                currentStudentName.textContent = "No hay estudiantes o r√∫brica cargada";
                studentIndexSpan.textContent = "0";
                totalStudentsSpan.textContent = "0";
                studentRubricDisplay.innerHTML = "";
                return;
            }

            const studentName = currentStudents[currentStudentIndex];
            currentStudentName.textContent = studentName;
            studentIndexSpan.textContent = currentStudentIndex + 1;
            totalStudentsSpan.textContent = currentStudents.length;

            const evaluationKey = `${groupSelect.value}_${studentName}`;

            let tableHTML = `
                <table class="min-w-full bg-white border border-gray-300 rounded-lg overflow-hidden shadow-sm">
                    <thead class="bg-gray-100">
                        <tr>
                            <th class="py-3 px-4 text-left text-gray-700 font-semibold border-b">Aspecto</th>
                            <th class="py-3 px-4 text-left text-gray-700 font-semibold border-b">Nivel Asignado</th>
                            <th class="py-3 px-4 text-left text-gray-700 font-semibold border-b">Puntaje</th>
                            <th class="py-3 px-4 text-left text-gray-700 font-semibold border-b">Descriptores (Haz clic para asignar)</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            let totalScore = 0;
            let evaluatedAspectsCount = 0;

            currentRubric.aspects.forEach(aspect => {
                const currentLevel = evaluations[evaluationKey] ? evaluations[evaluationKey][aspect] : null;
                const currentScore = currentLevel ? currentRubric.levelScores[currentLevel] || 0 : 0;
                
                if (currentLevel) {
                    totalScore += currentScore;
                    evaluatedAspectsCount++;
                }
                
                tableHTML += `
                    <tr>
                        <td class="py-3 px-4 border-b text-gray-800 font-medium">${aspect}</td>
                        <td class="py-3 px-4 border-b">
                            <span class="font-bold text-blue-600">${currentLevel || 'N/A'}</span>
                        </td>
                        <td class="py-3 px-4 border-b">
                            <span class="font-bold text-green-600">${currentScore}</span>
                        </td>
                        <td class="py-2 px-4 border-b">
                            <div class="flex flex-wrap gap-2">
                                ${currentRubric.levels.map(level => {
                                    const descriptor = currentRubric.descriptors[aspect][level] || 'Sin descriptor';
                                    const isSelected = currentLevel === level;
                                    const buttonClasses = `
                                        flex-grow min-w-0 p-2 text-sm border rounded-md cursor-pointer
                                        ${isSelected ? 'bg-blue-200 border-blue-500 text-blue-800 shadow-md' : 'bg-gray-100 border-gray-300 text-gray-700 hover:bg-gray-200'}
                                        transition duration-200 ease-in-out
                                        text-left
                                    `;
                                    return `
                                        <button
                                            data-aspect="${aspect}"
                                            data-level="${level}"
                                            class="${buttonClasses}"
                                            title="${descriptor}"
                                        >
                                            <span class="font-semibold">${level} (${currentRubric.levelScores[level] || 0} pts):</span> ${descriptor}
                                        </button>
                                    `;
                                }).join('')}
                            </div>
                        </td>
                    </tr>
                `;
            });

            const averageScore = evaluatedAspectsCount > 0 ? (totalScore / evaluatedAspectsCount).toFixed(1) : 0;
            const performanceLevel = getPerformanceLevel(parseFloat(averageScore));

            tableHTML += `
                    </tbody>
                    <tfoot>
                        <tr>
                            <td class="py-3 px-4 border-t font-bold text-gray-800">Total</td>
                            <td class="py-3 px-4 border-t font-bold text-gray-800"></td>
                            <td class="py-3 px-4 border-t font-bold text-green-600">${totalScore}</td>
                            <td class="py-3 px-4 border-t font-bold text-gray-800"></td>
                        </tr>
                        <tr>
                            <td class="py-3 px-4 border-t font-bold text-gray-800">Promedio</td>
                            <td class="py-3 px-4 border-t font-bold text-gray-800"></td>
                            <td class="py-3 px-4 border-t font-bold text-green-600">${averageScore}</td>
                            <td class="py-3 px-4 border-t font-bold text-gray-800">
                                <span class="performance-level ${performanceLevel.class}">${performanceLevel.level}</span>
                            </td>
                        </tr>
                    </tfoot>
                </table>
                <div class="mt-4 p-3 bg-gray-50 rounded-lg">
                    <h4 class="font-semibold mb-2">R√∫brica: ${currentRubric.name}</h4>
                </div>
            `;
            studentRubricDisplay.innerHTML = tableHTML;

            // Attach event listeners to newly rendered buttons
            studentRubricDisplay.querySelectorAll('button[data-aspect][data-level]').forEach(button => {
                button.addEventListener('click', (event) => {
                    const aspect = event.currentTarget.dataset.aspect;
                    const level = event.currentTarget.dataset.level;
                    evaluateAspect(studentName, aspect, level);
                });
            });

            // Control navigation buttons
            prevStudentBtn.disabled = currentStudentIndex === 0;
            nextStudentBtn.disabled = currentStudentIndex === currentStudents.length - 1;
            if (currentStudentIndex === currentStudents.length - 1) {
                finishEvaluationBtn.classList.remove('hidden');
                nextStudentBtn.classList.add('hidden');
            } else {
                finishEvaluationBtn.classList.add('hidden');
                nextStudentBtn.classList.remove('hidden');
            }
        }

        /**
         * Records the evaluation for a specific aspect of a student.
         * @param {string} studentName - The name of the student.
         * @param {string} aspect - The rubric aspect being evaluated.
         * @param {string} level - The performance level assigned.
         */
        function evaluateAspect(studentName, aspect, level) {
            const evaluationKey = `${groupSelect.value}_${studentName}`;
            if (!evaluations[evaluationKey]) {
                evaluations[evaluationKey] = {};
            }
            evaluations[evaluationKey][aspect] = level;
            saveData();
            renderStudentEvaluation(); // Re-render to update scores and selected buttons
            showMessage(evaluationMessageBox, `Evaluaci√≥n para '${aspect}' del estudiante '${studentName}' actualizada a '${level}'.`, 'success');
        }

        prevStudentBtn.addEventListener('click', () => {
            if (currentStudentIndex > 0) {
                currentStudentIndex--;
                renderStudentEvaluation();
            }
        });

        nextStudentBtn.addEventListener('click', () => {
            if (currentStudentIndex < currentStudents.length - 1) {
                currentStudentIndex++;
                renderStudentEvaluation();
            }
        });

        finishEvaluationBtn.addEventListener('click', () => {
            showSection('report-section');
        });

        backToEvaluationBtn.addEventListener('click', () => {
            showSection('evaluation-section');
            renderStudentEvaluation(); // Ensure current student is displayed
        });

        newEvaluationBtn.addEventListener('click', async () => {
            const confirm = await showConfirmModal("¬øEst√°s seguro de que quieres iniciar una nueva evaluaci√≥n? Esto borrar√° las evaluaciones actuales pero mantendr√° tus grupos y r√∫bricas guardadas.");
            if (confirm) {
                resetApp();
            }
        });

        // --- PDF and CSV Export Logic ---

        /**
         * Generates a PDF report for a single student based on their rubric evaluation.
         * Includes both the full rubric matrix and the student's specific evaluation.
         * @param {string} studentName - The name of the student.
         * @param {string} groupName - The name of the student group.
         */
        function generateSingleStudentPdf(studentName, groupName) {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({
                orientation: 'landscape',
                unit: 'mm',
                format: 'a4'
            });

            doc.setFont("helvetica");
            let yOffset = 20;
            const margin = 20;

            // Title and header
            doc.setFontSize(22);
            doc.setTextColor(40, 40, 40);
            doc.text("R√∫brica de Evaluaci√≥n", doc.internal.pageSize.width / 2, yOffset, { align: 'center' });
            yOffset += 10;

            doc.setFontSize(14);
            doc.setTextColor(50, 50, 50);
            doc.text(`Grupo: ${groupName || 'N/A'}`, doc.internal.pageSize.width / 2, yOffset, { align: 'center' });
            yOffset += 10;

            doc.setFontSize(10);
            doc.setTextColor(80, 80, 80);
            doc.text(`R√∫brica: ${currentRubric.name || 'N/A'}`, margin, yOffset);
            yOffset += 5;
            doc.text(`Estudiante: ${studentName || 'N/A'}`, margin, yOffset);
            yOffset += 15;

            // Display full rubric matrix
            doc.setFontSize(12);
            doc.setTextColor(0, 0, 0);
            doc.text("Matriz Completa de la R√∫brica:", margin, yOffset);
            yOffset += 7;

            const rubricHeaders = ["Aspecto", ...currentRubric.levels.map(level => `${level} (${currentRubric.levelScores[level]} pts)`)];
            // Calculate column widths based on available space and number of levels
            const availableWidth = doc.internal.pageSize.width - 2 * margin;
            const aspectColWidth = 40;
            const levelColWidth = (availableWidth - aspectColWidth) / currentRubric.levels.length;
            const rubricColumnWidths = [aspectColWidth, ...Array(currentRubric.levels.length).fill(levelColWidth)];


            const rubricTableData = currentRubric.aspects.map(aspect => {
                return [aspect, ...currentRubric.levels.map(level => currentRubric.descriptors[aspect][level] || '')];
            });

            doc.autoTable({
                startY: yOffset,
                head: [rubricHeaders],
                body: rubricTableData,
                theme: 'grid',
                styles: {
                    fontSize: 6,
                    cellPadding: 1,
                    valign: 'middle',
                    halign: 'left',
                    textColor: [50, 50, 50],
                },
                headStyles: {
                    fillColor: [220, 220, 220],
                    textColor: [0, 0, 0],
                    fontStyle: 'bold',
                },
                columnStyles: rubricHeaders.reduce((acc, _, index) => {
                    acc[index] = { cellWidth: rubricColumnWidths[index] };
                    return acc;
                }, {}),
                didDrawPage: function (data) {
                    let str = "P√°gina " + doc.internal.getNumberOfPages();
                    doc.setFontSize(8);
                    doc.setTextColor(150);
                    doc.text(str, data.settings.margin.left, doc.internal.pageSize.height - 10);
                }
            });

            yOffset = doc.autoTable.previous.finalY + 10;

            // Display specific student evaluation
            doc.setFontSize(12);
            doc.setTextColor(0, 0, 0);
            doc.text("Evaluaci√≥n del Estudiante:", margin, yOffset);
            yOffset += 7;

            const evaluationHeaders = ["Aspecto", "Nivel Asignado", "Puntaje", "Descriptor"];
            // Adjust column widths for evaluation table
            const evalAspectColWidth = 40;
            const evalLevelColWidth = 25;
            const evalScoreColWidth = 15;
            const evalDescriptorColWidth = availableWidth - evalAspectColWidth - evalLevelColWidth - evalScoreColWidth;
            const evaluationColumnWidths = [evalAspectColWidth, evalLevelColWidth, evalScoreColWidth, evalDescriptorColWidth];


            const evaluationKey = `${groupName}_${studentName}`;
            const evaluationTableData = [];
            let studentTotalScore = 0;
            let hasEvaluatedAspects = false;

            currentRubric.aspects.forEach(aspect => {
                const assignedLevel = evaluations[evaluationKey] ? evaluations[evaluationKey][aspect] || 'No Evaluado' : 'No Evaluado';
                const scoreForAspect = currentRubric.levelScores[assignedLevel] || 0;
                const descriptorText = currentRubric.descriptors[aspect][assignedLevel] || 'N/A';
                evaluationTableData.push([aspect, assignedLevel, scoreForAspect, descriptorText]);

                if (assignedLevel !== 'No Evaluado') { // Only add to total if evaluated
                    studentTotalScore += scoreForAspect;
                    hasEvaluatedAspects = true;
                }
            });

            let maxPossibleScore = 0;
            currentRubric.aspects.forEach(aspect => {
                let maxAspectScore = 0;
                currentRubric.levels.forEach(level => {
                    const score = currentRubric.levelScores[level] || 0;
                    if (score > maxAspectScore) {
                        maxAspectScore = score;
                    }
                });
                maxPossibleScore += maxAspectScore;
            });

            const studentAverageScore = hasEvaluatedAspects ? (studentTotalScore / currentRubric.aspects.length).toFixed(1) : 'N/A';
            const performanceLevel = getPerformanceLevel(parseFloat(studentAverageScore));

            doc.autoTable({
                startY: yOffset,
                head: [evaluationHeaders],
                body: evaluationTableData,
                theme: 'grid',
                styles: {
                    fontSize: 7,
                    cellPadding: 1.5,
                    valign: 'middle',
                    halign: 'left',
                    textColor: [50, 50, 50],
                },
                headStyles: {
                    fillColor: [220, 220, 220],
                    textColor: [0, 0, 0],
                    fontStyle: 'bold',
                },
                columnStyles: {
                    0: { cellWidth: evaluationColumnWidths[0] },
                    1: { cellWidth: evaluationColumnWidths[1] },
                    2: { cellWidth: evaluationColumnWidths[2], halign: 'center' },
                    3: { cellWidth: evaluationColumnWidths[3] }
                },
                 didDrawPage: function (data) {
                    let str = "P√°gina " + doc.internal.getNumberOfPages();
                    doc.setFontSize(8);
                    doc.setTextColor(150);
                    doc.text(str, data.settings.margin.left, doc.internal.pageSize.height - 10);
                }
            });

            yOffset = doc.autoTable.previous.finalY;

            // Final summary
            doc.setFontSize(10);
            doc.setTextColor(0, 100, 0);
            doc.text(`Puntaje Final: ${studentTotalScore} / ${maxPossibleScore} pts`, margin, yOffset + 5);
            doc.text(`Promedio por Aspecto: ${studentAverageScore}`, margin, yOffset + 10);
            doc.text(`Nivel de Desempe√±o: ${performanceLevel.level}`, margin, yOffset + 15);

            const safeStudentName = studentName.replace(/[^a-z0-9]/gi, '_');
            const safeGroupName = groupName.replace(/[^a-z0-9]/gi, '_');
            doc.save(`rubrica_${safeStudentName}_${safeGroupName}.pdf`);
        }

        exportIndividualRubricsBtn.addEventListener('click', async () => {
            if (currentStudents.length === 0) {
                showMessage(reportMessageBox, "No hay estudiantes en el grupo actual para generar reportes individuales.", 'error');
                return;
            }
            if (!currentRubric) {
                showMessage(reportMessageBox, "No hay una r√∫brica seleccionada para exportar.", 'error');
                return;
            }

            const currentGroupName = groupSelect.value;
            for (const student of currentStudents) {
                // Check if the student has any evaluation data for the current rubric
                const evaluationKey = `${currentGroupName}_${student}`;
                if (evaluations[evaluationKey] && Object.keys(evaluations[evaluationKey]).length > 0) {
                    generateSingleStudentPdf(student, currentGroupName);
                } else {
                    showMessage(reportMessageBox, `Advertencia: El estudiante '${student}' no tiene evaluaciones para esta r√∫brica. Se omiti√≥ la generaci√≥n de su PDF individual.`, 'error');
                }
            }
            showMessage(reportMessageBox, "¬°R√∫bricas individuales generadas y descargadas!", 'success');
        });

        exportPdfBtn.addEventListener('click', async () => {
            if (currentStudents.length === 0) {
                showMessage(reportMessageBox, "No hay estudiantes en el grupo actual para generar el reporte.", 'error');
                return;
            }
            if (!currentRubric) {
                showMessage(reportMessageBox, "No hay una r√∫brica seleccionada para exportar.", 'error');
                return;
            }

            const { jsPDF } = window.jspdf;
            // Create a single PDF for all students
            const doc = new jsPDF({
                orientation: 'portrait', // Changed to portrait for general report
                unit: 'mm',
                format: 'a4'
            });

            doc.setFont("helvetica");

            const currentGroupName = groupSelect.value;
            let finalReportTableData = [];
            let finalReportHeaders = ["Estudiante", ...currentRubric.aspects, "Puntaje Total", "Promedio", "Nivel Desempe√±o"];
            
            // Add a starting page
            doc.addPage();
            let yOffset = 20;
            const margin = 20;

            doc.setFontSize(22);
            doc.setTextColor(40, 40, 40);
            doc.text("Reporte General de Evaluaci√≥n", doc.internal.pageSize.width / 2, yOffset, { align: 'center' });
            yOffset += 10;

            doc.setFontSize(14);
            doc.setTextColor(50, 50, 50);
            doc.text(`Grupo: ${currentGroupName || 'N/A'}`, doc.internal.pageSize.width / 2, yOffset, { align: 'center' });
            yOffset += 10;
            doc.text(`R√∫brica: ${currentRubric.name || 'N/A'}`, doc.internal.pageSize.width / 2, yOffset, { align: 'center' });
            yOffset += 15;


            currentStudents.forEach(student => {
                const evaluationKey = `${currentGroupName}_${student}`;
                let rowData = [student];
                let studentTotalScore = 0;
                let evaluatedAspectsCount = 0;

                currentRubric.aspects.forEach(aspect => {
                    const assignedLevel = evaluations[evaluationKey] ? evaluations[evaluationKey][aspect] || '' : '';
                    const scoreForAspect = assignedLevel ? currentRubric.levelScores[assignedLevel] || 0 : 0;
                    
                    if (assignedLevel) {
                        studentTotalScore += scoreForAspect;
                        evaluatedAspectsCount++;
                    }
                    rowData.push(assignedLevel);
                });

                const studentAverageScore = evaluatedAspectsCount > 0 ? (studentTotalScore / evaluatedAspectsCount).toFixed(1) : 'N/A';
                const performanceLevel = getPerformanceLevel(parseFloat(studentAverageScore));
                
                rowData.push(studentTotalScore);
                rowData.push(studentAverageScore);
                rowData.push(performanceLevel.level);
                
                finalReportTableData.push(rowData);
            });

            doc.autoTable({
                startY: yOffset,
                head: [finalReportHeaders],
                body: finalReportTableData,
                theme: 'grid',
                styles: {
                    fontSize: 8,
                    cellPadding: 1.5,
                    valign: 'middle',
                    halign: 'left',
                    textColor: [50, 50, 50],
                },
                headStyles: {
                    fillColor: [220, 220, 220],
                    textColor: [0, 0, 0],
                    fontStyle: 'bold',
                },
                didDrawPage: function (data) {
                    let str = "P√°gina " + doc.internal.getNumberOfPages();
                    doc.setFontSize(8);
                    doc.setTextColor(150);
                    doc.text(str, data.settings.margin.left, doc.internal.pageSize.height - 10);
                }
            });

            doc.save(`reporte_general_${currentGroupName}.pdf`);
            showMessage(reportMessageBox, "¬°Reporte PDF generado y descargado!", 'success');
        });

        exportCsvBtn.addEventListener('click', () => {
            if (currentStudents.length === 0) {
                showMessage(reportMessageBox, "No hay estudiantes en el grupo actual para exportar.", 'error');
                return;
            }
            if (!currentRubric) {
                showMessage(reportMessageBox, "No hay una r√∫brica seleccionada para exportar.", 'error');
                return;
            }

            const currentGroupName = groupSelect.value;
            let csvContent = "data:text/csv;charset=utf-8,";
            
            // Headers
            const headers = ["Estudiante", ...currentRubric.aspects, "Puntaje Total", "Promedio", "Nivel de Desempe√±o"];
            csvContent += headers.map(h => `"${h}"`).join(",") + "\r\n";

            currentStudents.forEach(student => {
                const evaluationKey = `${currentGroupName}_${student}`;
                let rowData = [student];
                let totalScore = 0;
                let evaluatedAspectsCount = 0;

                currentRubric.aspects.forEach(aspect => {
                    const assignedLevel = evaluations[evaluationKey] ? evaluations[evaluationKey][aspect] || '' : '';
                    const scoreForAspect = assignedLevel ? currentRubric.levelScores[assignedLevel] || 0 : 0;
                    
                    if (assignedLevel) {
                        totalScore += scoreForAspect;
                        evaluatedAspectsCount++;
                    }
                    
                    rowData.push(assignedLevel);
                });

                const averageScore = evaluatedAspectsCount > 0 ? (totalScore / evaluatedAspectsCount).toFixed(1) : 0;
                const performanceLevel = getPerformanceLevel(parseFloat(averageScore));
                
                rowData.push(totalScore);
                rowData.push(averageScore);
                rowData.push(performanceLevel.level);
                
                csvContent += rowData.map(item => `"${item}"`).join(",") + "\r\n";
            });

            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", `evaluaciones_${currentGroupName}.csv`);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            showMessage(reportMessageBox, "¬°Datos exportados a CSV correctamente!", 'success');
        });

        // --- Initialization ---

        window.onload = loadData; // Load saved data when the page loads

    </script>
</body>
</html>
