
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Evaluador de Estudiantes por Rúbrica</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
        }
        .container {
            background-color: #ffffff;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            padding: 30px;
            max-width: 1000px;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 20px;
            transition: all 0.3s ease-in-out;
        }
        textarea {
            min-height: 150px;
            resize: vertical;
        }
        button {
            transition: background-color 0.3s ease, transform 0.2s ease;
        }
        button:hover {
            transform: translateY(-2px);
        }
        button:active {
            transform: translateY(0);
        }
        .message-box {
            background-color: #e0f2f7;
            color: #0288d1;
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            text-align: center;
            display: none;
        }
        .message-box.error {
            background-color: #ffebee;
            color: #d32f2f;
        }
        .message-box.success {
            background-color: #e8f5e9;
            color: #388e3c;
        }
        .performance-level {
            font-weight: bold;
            padding: 3px 8px;
            border-radius: 4px;
            margin-left: 10px;
        }
        .performance-level.previous {
            background-color: #ffcccc;
            color: #cc0000;
        }
        .performance-level.beginning {
            background-color: #ffebcc;
            color: #cc7a00;
        }
        .performance-level.process {
            background-color: #ffffcc;
            color: #999900;
        }
        .performance-level.achieved {
            background-color: #e6ffe6;
            color: #006600;
        }
        .performance-level.outstanding {
            background-color: #e6f7ff;
            color: #0066cc;
        }
        .rubric-preview {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
            margin-top: 10px;
            background-color: #f9f9f9;
        }
        .rubric-preview table {
            width: 100%;
            border-collapse: collapse;
        }
        .rubric-preview th, .rubric-preview td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        .rubric-preview th {
            background-color: #f2f2f2;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-3xl md:text-4xl font-bold text-center text-gray-800 mb-6">Evaluador de Estudiantes</h1>

        <!-- Sección de Añadir Estudiantes -->
        <div id="add-students-section" class="bg-blue-50 p-6 rounded-xl border border-blue-200">
            <h2 class="text-2xl font-semibold text-gray-700 mb-4 text-center">1. Agregar y Gestionar Estudiantes</h2>
            
            <div class="mb-4">
                <label for="group-name-input" class="block text-gray-700 font-medium mb-2">Nombre del Nuevo Grupo de Estudiantes (opcional):</label>
                <input
                    type="text"
                    id="group-name-input"
                    class="w-full p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 transition duration-200"
                    placeholder="Ej: Grupo A, Ciencias Sociales"
                />
            </div>

            <p class="text-gray-600 mb-2 text-center">Pega aquí la lista de nombres de tus estudiantes (uno por línea).</p>
            <textarea
                id="student-list-input"
                class="w-full p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 transition duration-200"
                placeholder="Ejemplo:&#10;Juan Pérez&#10;María García&#10;Carlos López"
            ></textarea>
            <button
                id="add-students-btn"
                class="w-full bg-blue-600 text-white font-semibold py-3 px-6 mt-4 rounded-xl shadow-md hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-300"
            >
                Guardar Lista de Estudiantes
            </button>
            <div id="student-message-box" class="message-box"></div>

            <div class="mt-6 border-t pt-4 border-gray-200">
                <h3 class="text-xl font-semibold text-gray-700 mb-4 text-center">Seleccionar Grupo para Evaluación</h3>
                <p class="text-gray-600 mb-2 text-center">O elige un grupo existente para evaluar:</p>
                <select id="group-select" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 transition duration-200">
                    <option value="">-- Seleccionar Grupo --</option>
                </select>
                <button
                    id="select-group-btn"
                    class="w-full bg-indigo-600 text-white font-semibold py-3 px-6 mt-4 rounded-xl shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-4 focus:ring-indigo-300"
                >
                    Cargar Grupo Seleccionado y Continuar
                </button>
                <button
                    id="delete-group-btn"
                    class="w-full bg-red-500 text-white font-semibold py-3 px-6 mt-2 rounded-xl shadow-md hover:bg-red-600 focus:outline-none focus:ring-4 focus:ring-red-300"
                >
                    Eliminar Grupo Seleccionado
                </button>
            </div>
        </div>

        <!-- Sección de Configuración de Rúbrica -->
        <div id="rubric-config-section" class="bg-green-50 p-6 rounded-xl border border-green-200 hidden">
            <h2 class="text-2xl font-semibold text-gray-700 mb-4 text-center">2. Configurar Rúbrica</h2>
            
            <div class="mb-6">
                <h3 class="text-xl font-semibold text-gray-700 mb-4">Seleccionar Rúbrica Existente</h3>
                <select id="rubric-select" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-green-500 focus:border-green-500 transition duration-200">
                    <option value="">-- Seleccionar Rúbrica --</option>
                </select>
                <button
                    id="delete-rubric-btn"
                    class="w-full bg-red-500 text-white font-semibold py-2 px-4 mt-2 rounded-lg shadow-md hover:bg-red-600 focus:outline-none focus:ring-4 focus:ring-red-300"
                >
                    Eliminar Rúbrica Seleccionada
                </button>
            </div>

            <div class="mb-6">
                <h3 class="text-xl font-semibold text-gray-700 mb-4">Importar Nueva Rúbrica desde CSV</h3>
                <p class="text-gray-600 mb-2">Formato requerido: Primera fila son los niveles de desempeño, primera columna son los aspectos a evaluar, celdas son los descriptores.</p>
                <label for="rubric-name-input" class="block text-gray-700 font-medium mb-2">Nombre de la Rúbrica:</label>
                <input
                    type="text"
                    id="rubric-name-input"
                    class="w-full p-3 border border-gray-300 rounded-lg focus:ring-green-500 focus:border-green-500 transition duration-200"
                    placeholder="Ej: Rúbrica de Presentaciones Orales"
                />
                <textarea
                    id="rubric-csv-input"
                    class="w-full p-3 border border-gray-300 rounded-lg focus:ring-green-500 focus:border-green-500 transition duration-200 mt-2"
                    placeholder="Pega aquí el contenido CSV de la rúbrica. Ejemplo:&#10;,Destacado,Logrado,En Proceso,En Inicio&#10;Coherencia,Descriptor 1,Descriptor 2,Descriptor 3,Descriptor 4&#10;Claridad,Descriptor 1,Descriptor 2,Descriptor 3,Descriptor 4"
                    rows="8"
                ></textarea>
                <div id="rubric-preview" class="rubric-preview hidden"></div>
                <button
                    id="preview-rubric-btn"
                    class="w-full bg-blue-500 text-white font-semibold py-2 px-4 mt-2 rounded-lg shadow-md hover:bg-blue-600 focus:outline-none focus:ring-4 focus:ring-blue-300"
                >
                    Previsualizar Rúbrica
                </button>
                <button
                    id="save-rubric-btn"
                    class="w-full bg-green-600 text-white font-semibold py-3 px-6 mt-2 rounded-xl shadow-md hover:bg-green-700 focus:outline-none focus:ring-4 focus:ring-green-300 hidden"
                >
                    Guardar Rúbrica y Empezar Evaluación
                </button>
            </div>
            <div id="rubric-config-message-box" class="message-box"></div>
        </div>

        <div id="evaluation-section" class="bg-yellow-50 p-6 rounded-xl border border-yellow-200 hidden">
            <h2 class="text-2xl font-semibold text-gray-700 mb-4 text-center">3. Evaluación de Estudiantes</h2>
            <div class="text-center mb-4">
                <p class="text-lg text-gray-800 font-semibold">Estudiante Actual: <span id="current-student-name" class="text-blue-600"></span></p>
                <p class="text-gray-600 text-sm">Estudiante <span id="student-index">1</span> de <span id="total-students">0</span></p>
            </div>
            <div id="student-rubric-display" class="overflow-x-auto">
                </div>
            <div class="flex flex-col sm:flex-row justify-center gap-4 mt-6">
                <button
                    id="prev-student-btn"
                    class="flex-1 bg-gray-400 text-white font-semibold py-3 px-6 rounded-xl shadow-md hover:bg-gray-500 focus:outline-none focus:ring-4 focus:ring-gray-300"
                >
                    Anterior
                </button>
                <button
                    id="next-student-btn"
                    class="flex-1 bg-blue-600 text-white font-semibold py-3 px-6 rounded-xl shadow-md hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-300"
                >
                    Siguiente Estudiante
                </button>
                <button
                    id="finish-evaluation-btn"
                    class="flex-1 bg-indigo-600 text-white font-semibold py-3 px-6 rounded-xl shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-4 focus:ring-indigo-300 hidden"
                >
                    Finalizar Evaluación y Exportar
                </button>
            </div>
            <div id="evaluation-message-box" class="message-box"></div>
        </div>

        <div id="report-section" class="bg-red-50 p-6 rounded-xl border border-red-200 hidden">
            <h2 class="text-2xl font-semibold text-gray-700 mb-4 text-center">4. Reporte y Exportación</h2>
            <p class="text-gray-600 mb-4 text-center">Haz clic para generar el reporte de todas las evaluaciones.</p>
            <div class="flex flex-col sm:flex-row justify-center gap-4 mt-6">
                <button
                    id="export-pdf-btn"
                    class="flex-1 bg-red-600 text-white font-semibold py-3 px-6 rounded-xl shadow-md hover:bg-red-700 focus:outline-none focus:ring-4 focus:ring-red-300"
                >
                    Exportar Reporte General a PDF
                </button>
                <button
                    id="export-individual-rubrics-btn"
                    class="flex-1 bg-teal-600 text-white font-semibold py-3 px-6 rounded-xl shadow-md hover:bg-teal-700 focus:outline-none focus:ring-4 focus:ring-teal-300"
                >
                    Exportar Rúbricas Individuales a PDF
                </button>
                <button
                    id="export-csv-btn"
                    class="flex-1 bg-green-600 text-white font-semibold py-3 px-6 rounded-xl shadow-md hover:bg-green-700 focus:outline-none focus:ring-4 focus:ring-green-300"
                >
                    Exportar a CSV
                </button>
            </div>
            <div class="flex flex-col sm:flex-row justify-center gap-4 mt-4">
                <button
                    id="back-to-evaluation-btn"
                    class="flex-1 bg-gray-600 text-white font-semibold py-3 px-6 rounded-xl shadow-md hover:bg-gray-700 focus:outline-none focus:ring-4 focus:ring-gray-300"
                >
                    Atrás (Modificar Evaluación)
                </button>
                <button
                    id="new-rubric-btn"
                    class="flex-1 bg-blue-600 text-white font-semibold py-3 px-6 rounded-xl shadow-md hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-300"
                >
                    Nueva Evaluación
                </button>
            </div>
            <div id="report-message-box" class="message-box"></div>
        </div>

    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.14/jspdf.plugin.autotable.min.js"></script>

    <script>
        // Obtener referencias a los elementos del DOM
        const addStudentsSection = document.getElementById('add-students-section');
        const groupNameInput = document.getElementById('group-name-input');
        const studentListInput = document.getElementById('student-list-input');
        const addStudentsBtn = document.getElementById('add-students-btn');
        const groupSelect = document.getElementById('group-select');
        const selectGroupBtn = document.getElementById('select-group-btn');
        const deleteGroupBtn = document.getElementById('delete-group-btn');
        const studentMessageBox = document.getElementById('student-message-box');

        const rubricConfigSection = document.getElementById('rubric-config-section');
        const rubricSelect = document.getElementById('rubric-select');
        const deleteRubricBtn = document.getElementById('delete-rubric-btn');
        const rubricNameInput = document.getElementById('rubric-name-input');
        const rubricCsvInput = document.getElementById('rubric-csv-input');
        const rubricPreview = document.getElementById('rubric-preview');
        const previewRubricBtn = document.getElementById('preview-rubric-btn');
        const saveRubricBtn = document.getElementById('save-rubric-btn');
        const rubricConfigMessageBox = document.getElementById('rubric-config-message-box');

        const evaluationSection = document.getElementById('evaluation-section');
        const currentStudentName = document.getElementById('current-student-name');
        const studentIndexSpan = document.getElementById('student-index');
        const totalStudentsSpan = document.getElementById('total-students');
        const studentRubricDisplay = document.getElementById('student-rubric-display');
        const prevStudentBtn = document.getElementById('prev-student-btn');
        const nextStudentBtn = document.getElementById('next-student-btn');
        const finishEvaluationBtn = document.getElementById('finish-evaluation-btn');
        const evaluationMessageBox = document.getElementById('evaluation-message-box');

        const reportSection = document.getElementById('report-section');
        const exportPdfBtn = document.getElementById('export-pdf-btn');
        const exportIndividualRubricsBtn = document.getElementById('export-individual-rubrics-btn');
        const exportCsvBtn = document.getElementById('export-csv-btn');
        const backToEvaluationBtn = document.getElementById('back-to-evaluation-btn');
        const newRubricBtn = document.getElementById('new-rubric-btn');
        const reportMessageBox = document.getElementById('report-message-box');

        // Variables globales para la aplicación
        let studentGroups = {};
        let currentStudents = [];
        let currentStudentIndex = 0;
        let savedRubrics = {};
        let currentRubric = null;

        let evaluations = {};

        // --- Funciones de Utilidad ---

        function showMessage(boxElement, message, type = '') {
            boxElement.textContent = message;
            boxElement.className = 'message-box';
            if (type) {
                boxElement.classList.add(type);
            }
            boxElement.style.display = 'block';
            setTimeout(() => {
                boxElement.style.display = 'none';
            }, 5000);
        }

        function loadData() {
            try {
                const storedStudentGroups = localStorage.getItem('studentGroups');
                if (storedStudentGroups) {
                    studentGroups = JSON.parse(storedStudentGroups);
                    renderGroupSelect();
                }

                const storedRubrics = localStorage.getItem('savedRubrics');
                if (storedRubrics) {
                    savedRubrics = JSON.parse(storedRubrics);
                    renderRubricSelect();
                }

                const storedCurrentGroup = localStorage.getItem('currentSelectedGroup');
                if(storedCurrentGroup && studentGroups[storedCurrentGroup]) {
                    currentStudents = studentGroups[storedCurrentGroup];
                    groupSelect.value = storedCurrentGroup;
                }

                const storedCurrentRubric = localStorage.getItem('currentRubric');
                if (storedCurrentRubric) {
                    currentRubric = JSON.parse(storedCurrentRubric);
                }

                const storedEvaluations = localStorage.getItem('evaluations');
                if (storedEvaluations) {
                    evaluations = JSON.parse(storedEvaluations);
                }

                if (currentStudents.length > 0) {
                    addStudentsSection.classList.add('hidden');
                    if (currentRubric) {
                        rubricConfigSection.classList.add('hidden');
                        evaluationSection.classList.remove('hidden');
                        renderStudentEvaluation();
                    } else {
                        rubricConfigSection.classList.remove('hidden');
                    }
                }

            } catch (e) {
                console.error("Error al cargar datos de localStorage:", e);
                showMessage(studentMessageBox, "Error al cargar datos guardados. Los datos pueden estar corruptos.", 'error');
            }
        }

        function saveData() {
            try {
                localStorage.setItem('studentGroups', JSON.stringify(studentGroups));
                localStorage.setItem('savedRubrics', JSON.stringify(savedRubrics));
                localStorage.setItem('evaluations', JSON.stringify(evaluations));
                localStorage.setItem('currentSelectedGroup', groupSelect.value);
                if (currentRubric) {
                    localStorage.setItem('currentRubric', JSON.stringify(currentRubric));
                }
            } catch (e) {
                console.error("Error al guardar datos en localStorage:", e);
                showMessage(studentMessageBox, "No se pudieron guardar los datos. Verifique el espacio disponible en su navegador.", 'error');
            }
        }

        function resetApp() {
            localStorage.removeItem('currentRubric');
            localStorage.removeItem('evaluations');

            currentRubric = null;
            evaluations = {};

            evaluationSection.classList.add('hidden');
            rubricConfigSection.classList.remove('hidden');
            reportSection.classList.add('hidden');
            addStudentsSection.classList.add('hidden');

            showMessage(reportMessageBox, "La evaluación ha sido reiniciada. Tus grupos y rúbricas permanecen guardados.", 'success');
        }

        // --- Lógica de Añadir y Gestionar Estudiantes ---

        function renderGroupSelect() {
            groupSelect.innerHTML = '<option value="">-- Seleccionar Grupo --</option>';
            for (const groupName in studentGroups) {
                const option = document.createElement('option');
                option.value = groupName;
                option.textContent = groupName;
                groupSelect.appendChild(option);
            }
        }

        addStudentsBtn.addEventListener('click', () => {
            const rawList = studentListInput.value.trim();
            let groupName = groupNameInput.value.trim();
            const selectedGroup = groupSelect.value;

            if (!rawList) {
                showMessage(studentMessageBox, "Por favor, introduce la lista de estudiantes.", 'error');
                return;
            }

            const newStudents = rawList.split('\n')
                                      .map(name => name.trim())
                                      .filter(name => name !== '')
                                      .filter((name, index, self) => self.indexOf(name) === index);

            if (newStudents.length === 0) {
                showMessage(studentMessageBox, "No se encontraron nombres de estudiantes válidos en la lista.", 'error');
                return;
            }

            let targetGroupName;
            let actionMessage = "";

            if (groupName) {
                targetGroupName = groupName;
                studentGroups[targetGroupName] = newStudents;
                actionMessage = `¡Grupo "${targetGroupName}" con ${newStudents.length} estudiantes guardado (o actualizado)!`;
            } else if (selectedGroup) {
                targetGroupName = selectedGroup;
                const existingStudents = studentGroups[targetGroupName] || [];
                const combinedStudents = [...new Set([...existingStudents, ...newStudents])];
                studentGroups[targetGroupName] = combinedStudents;
                actionMessage = `¡${newStudents.length} estudiantes añadidos al grupo "${targetGroupName}"! Total: ${combinedStudents.length} estudiantes.`;
            } else {
                targetGroupName = `Grupo - ${new Date().toLocaleDateString('es-ES')}`;
                let counter = 1;
                while(studentGroups[targetGroupName]) {
                    targetGroupName = `Grupo - ${new Date().toLocaleDateString('es-ES')} (${counter})`;
                    counter++;
                }
                studentGroups[targetGroupName] = newStudents;
                actionMessage = `¡Nuevo grupo anónimo "${targetGroupName}" con ${newStudents.length} estudiantes creado!`;
            }

            currentStudents = studentGroups[targetGroupName];
            renderGroupSelect();
            groupSelect.value = targetGroupName;
            saveData();
            showMessage(studentMessageBox, actionMessage, 'success');

            groupNameInput.value = '';
            studentListInput.value = '';
        });

        selectGroupBtn.addEventListener('click', () => {
            const selectedGroup = groupSelect.value;
            if (!selectedGroup) {
                showMessage(studentMessageBox, "Por favor, selecciona un grupo de estudiantes.", 'error');
                return;
            }

            currentStudents = studentGroups[selectedGroup];
            saveData();
            showMessage(studentMessageBox, `¡Grupo "${selectedGroup}" cargado para evaluación!`, 'success');

            addStudentsSection.classList.add('hidden');
            rubricConfigSection.classList.remove('hidden');
            currentStudentIndex = 0;
        });

        deleteGroupBtn.addEventListener('click', () => {
            const selectedGroup = groupSelect.value;
            if (!selectedGroup) {
                showMessage(studentMessageBox, "Por favor, selecciona un grupo para eliminar.", 'error');
                return;
            }

            const confirmDelete = window.confirm(`¿Estás seguro de que quieres eliminar el grupo "${selectedGroup}"? Ten en cuenta que esto NO eliminará las evaluaciones asociadas a este grupo si ya se han realizado. Para borrar evaluaciones individuales, necesitarías reiniciar la rúbrica.`);
            if (confirmDelete) {
                delete studentGroups[selectedGroup];
                if (localStorage.getItem('currentSelectedGroup') === selectedGroup) {
                    localStorage.removeItem('currentSelectedGroup');
                    currentStudents = [];
                }
                renderGroupSelect();
                saveData();
                showMessage(studentMessageBox, `Grupo "${selectedGroup}" eliminado.`, 'success');
            }
        });

        // --- Lógica de Configuración de Rúbrica ---

        function renderRubricSelect() {
            rubricSelect.innerHTML = '<option value="">-- Seleccionar Rúbrica --</option>';
            for (const rubricName in savedRubrics) {
                const option = document.createElement('option');
                option.value = rubricName;
                option.textContent = rubricName;
                rubricSelect.appendChild(option);
            }
        }

        function parseRubricFromCSV(csvText) {
            const lines = csvText.split('\n').filter(line => line.trim() !== '');
            if (lines.length < 2) {
                showMessage(rubricConfigMessageBox, "El formato del CSV no es válido. Debe tener al menos 2 líneas (encabezados y al menos un aspecto).", 'error');
                return null;
            }

            // Extraer niveles (primera fila, omitiendo la primera celda vacía)
            const levels = lines[0].split(',').slice(1).map(level => level.trim());
            if (levels.length === 0) {
                showMessage(rubricConfigMessageBox, "No se encontraron niveles de desempeño en la primera fila del CSV.", 'error');
                return null;
            }

            // Extraer aspectos y descriptores
            const aspects = [];
            const descriptors = {};
            const levelScores = {};
            
            // Asignar puntajes predeterminados basados en la posición (5, 4, 3, 2, 1)
            levels.forEach((level, index) => {
                levelScores[level] = levels.length - index;
            });

            for (let i = 1; i < lines.length; i++) {
                const cells = lines[i].split(',');
                const aspect = cells[0].trim();
                if (!aspect) continue;

                aspects.push(aspect);
                descriptors[aspect] = {};

                for (let j = 1; j < cells.length; j++) {
                    const level = levels[j - 1];
                    if (!level) continue;

                    descriptors[aspect][level] = cells[j].trim();
                }
            }

            if (aspects.length === 0) {
                showMessage(rubricConfigMessageBox, "No se encontraron aspectos válidos en el CSV.", 'error');
                return null;
            }

            return {
                name: rubricNameInput.value.trim() || `Rúbrica ${new Date().toLocaleDateString('es-ES')}`,
                aspects,
                levels,
                descriptors,
                levelScores,
                generalObservations: ""
            };
        }

        function previewRubric(rubricData) {
            let previewHTML = '<h4 class="font-semibold mb-2">Vista previa de la rúbrica:</h4>';
            previewHTML += '<table><thead><tr><th>Aspecto</th>';
            
            // Encabezados de niveles
            rubricData.levels.forEach(level => {
                previewHTML += `<th>${level} (${rubricData.levelScores[level]} pts)</th>`;
            });
            previewHTML += '</tr></thead><tbody>';
            
            // Filas de aspectos y descriptores
            rubricData.aspects.forEach(aspect => {
                previewHTML += `<tr><td>${aspect}</td>`;
                rubricData.levels.forEach(level => {
                    previewHTML += `<td>${rubricData.descriptors[aspect][level] || ''}</td>`;
                });
                previewHTML += '</tr>';
            });
            
            previewHTML += '</tbody></table>';
            rubricPreview.innerHTML = previewHTML;
            rubricPreview.classList.remove('hidden');
            saveRubricBtn.classList.remove('hidden');
        }

        previewRubricBtn.addEventListener('click', () => {
            const rubricName = rubricNameInput.value.trim();
            if (!rubricName) {
                showMessage(rubricConfigMessageBox, "Por favor, introduce un nombre para la rúbrica.", 'error');
                return;
            }

            const csvText = rubricCsvInput.value.trim();
            if (!csvText) {
                showMessage(rubricConfigMessageBox, "Por favor, pega el contenido CSV de la rúbrica.", 'error');
                return;
            }

            const parsedRubric = parseRubricFromCSV(csvText);
            if (parsedRubric) {
                previewRubric(parsedRubric);
                showMessage(rubricConfigMessageBox, "Rúbrica analizada correctamente. Verifica la vista previa antes de guardar.", 'success');
            }
        });

        saveRubricBtn.addEventListener('click', () => {
            const rubricName = rubricNameInput.value.trim();
            if (!rubricName) {
                showMessage(rubricConfigMessageBox, "Por favor, introduce un nombre para la rúbrica.", 'error');
                return;
            }

            const csvText = rubricCsvInput.value.trim();
            if (!csvText) {
                showMessage(rubricConfigMessageBox, "Por favor, pega el contenido CSV de la rúbrica.", 'error');
                return;
            }

            const parsedRubric = parseRubricFromCSV(csvText);
            if (parsedRubric) {
                savedRubrics[rubricName] = parsedRubric;
                currentRubric = parsedRubric;
                saveData();
                renderRubricSelect();
                
                rubricConfigSection.classList.add('hidden');
                evaluationSection.classList.remove('hidden');
                currentStudentIndex = 0;
                renderStudentEvaluation();
                
                showMessage(rubricConfigMessageBox, "¡Rúbrica guardada y lista para la evaluación!", 'success');
            }
        });

        rubricSelect.addEventListener('change', () => {
            const selectedRubricName = rubricSelect.value;
            if (selectedRubricName && savedRubrics[selectedRubricName]) {
                currentRubric = savedRubrics[selectedRubricName];
                saveData();
                
                rubricConfigSection.classList.add('hidden');
                evaluationSection.classList.remove('hidden');
                currentStudentIndex = 0;
                renderStudentEvaluation();
            }
        });

        deleteRubricBtn.addEventListener('click', () => {
            const selectedRubricName = rubricSelect.value;
            if (!selectedRubricName) {
                showMessage(rubricConfigMessageBox, "Por favor, selecciona una rúbrica para eliminar.", 'error');
                return;
            }

            const confirmDelete = window.confirm(`¿Estás seguro de que quieres eliminar la rúbrica "${selectedRubricName}"?`);
            if (confirmDelete) {
                delete savedRubrics[selectedRubricName];
                if (currentRubric && currentRubric.name === selectedRubricName) {
                    currentRubric = null;
                    localStorage.removeItem('currentRubric');
                }
                saveData();
                renderRubricSelect();
                showMessage(rubricConfigMessageBox, `Rúbrica "${selectedRubricName}" eliminada.`, 'success');
            }
        });

        // --- Lógica de Evaluación de Estudiantes ---

        function getPerformanceLevel(averageScore) {
            if (averageScore >= 1 && averageScore < 2) return { level: "Previo al inicio", class: "previous" };
            if (averageScore >= 2 && averageScore < 3) return { level: "Inicio", class: "beginning" };
            if (averageScore >= 3 && averageScore < 4) return { level: "En proceso", class: "process" };
            if (averageScore >= 4 && averageScore < 5) return { level: "Logrado", class: "achieved" };
            if (averageScore === 5) return { level: "Destacado", class: "outstanding" };
            return { level: "No evaluado", class: "" };
        }

        function renderStudentEvaluation() {
            if (!currentRubric || currentStudents.length === 0) {
                currentStudentName.textContent = "No hay estudiantes o rúbrica";
                studentRubricDisplay.innerHTML = "";
                return;
            }

            const studentName = currentStudents[currentStudentIndex];
            currentStudentName.textContent = studentName;
            studentIndexSpan.textContent = currentStudentIndex + 1;
            totalStudentsSpan.textContent = currentStudents.length;

            const evaluationKey = `${groupSelect.value}_${studentName}`;

            let tableHTML = `
                <table class="min-w-full bg-white border border-gray-300 rounded-lg overflow-hidden shadow-sm">
                    <thead class="bg-gray-100">
                        <tr>
                            <th class="py-3 px-4 text-left text-gray-700 font-semibold border-b">Aspecto</th>
                            <th class="py-3 px-4 text-left text-gray-700 font-semibold border-b">Nivel Asignado</th>
                            <th class="py-3 px-4 text-left text-gray-700 font-semibold border-b">Puntaje</th>
                            <th class="py-3 px-4 text-left text-gray-700 font-semibold border-b">Descriptores (Haz clic para asignar)</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            let totalScore = 0;
            let evaluatedAspectsCount = 0;

            currentRubric.aspects.forEach(aspect => {
                const currentLevel = evaluations[evaluationKey] ? evaluations[evaluationKey][aspect] : null;
                const currentScore = currentLevel ? currentRubric.levelScores[currentLevel] || 0 : 0;
                
                if (currentLevel) {
                    totalScore += currentScore;
                    evaluatedAspectsCount++;
                }
                
                tableHTML += `
                    <tr>
                        <td class="py-3 px-4 border-b text-gray-800 font-medium">${aspect}</td>
                        <td class="py-3 px-4 border-b">
                            <span class="font-bold text-blue-600">${currentLevel || 'N/A'}</span>
                        </td>
                        <td class="py-3 px-4 border-b">
                            <span class="font-bold text-green-600">${currentScore}</span>
                        </td>
                        <td class="py-2 px-4 border-b">
                            <div class="flex flex-wrap gap-2">
                                ${currentRubric.levels.map(level => {
                                    const descriptor = currentRubric.descriptors[aspect][level] || 'Sin descriptor';
                                    const isSelected = currentLevel === level;
                                    const buttonClasses = `
                                        flex-grow min-w-0 p-2 text-sm border rounded-md cursor-pointer
                                        ${isSelected ? 'bg-blue-200 border-blue-500 text-blue-800 shadow-md' : 'bg-gray-100 border-gray-300 text-gray-700 hover:bg-gray-200'}
                                        transition duration-200 ease-in-out
                                        text-left
                                    `;
                                    return `
                                        <button
                                            data-aspect="${aspect}"
                                            data-level="${level}"
                                            class="${buttonClasses}"
                                            title="${descriptor}"
                                        >
                                            <span class="font-semibold">${level} (${currentRubric.levelScores[level] || 0} pts):</span> ${descriptor}
                                        </button>
                                    `;
                                }).join('')}
                            </div>
                        </td>
                    </tr>
                `;
            });

            const averageScore = evaluatedAspectsCount > 0 ? (totalScore / evaluatedAspectsCount).toFixed(1) : 0;
            const performanceLevel = getPerformanceLevel(parseFloat(averageScore));

            tableHTML += `
                    </tbody>
                    <tfoot>
                        <tr>
                            <td class="py-3 px-4 border-t font-bold text-gray-800">Total</td>
                            <td class="py-3 px-4 border-t font-bold text-gray-800"></td>
                            <td class="py-3 px-4 border-t font-bold text-green-600">${totalScore}</td>
                            <td class="py-3 px-4 border-t font-bold text-gray-800"></td>
                        </tr>
                        <tr>
                            <td class="py-3 px-4 border-t font-bold text-gray-800">Promedio</td>
                            <td class="py-3 px-4 border-t font-bold text-gray-800"></td>
                            <td class="py-3 px-4 border-t font-bold text-green-600">${averageScore}</td>
                            <td class="py-3 px-4 border-t font-bold text-gray-800">
                                <span class="performance-level ${performanceLevel.class}">${performanceLevel.level}</span>
                            </td>
                        </tr>
                    </tfoot>
                </table>
                <div class="mt-4 p-3 bg-gray-50 rounded-lg">
                    <h4 class="font-semibold mb-2">Rúbrica: ${currentRubric.name}</h4>
                </div>
            `;
            studentRubricDisplay.innerHTML = tableHTML;

            studentRubricDisplay.querySelectorAll('button[data-aspect][data-level]').forEach(button => {
                button.addEventListener('click', (event) => {
                    const aspect = event.currentTarget.dataset.aspect;
                    const level = event.currentTarget.dataset.level;
                    evaluateAspect(studentName, aspect, level);
                });
            });

            prevStudentBtn.disabled = currentStudentIndex === 0;
            nextStudentBtn.disabled = currentStudentIndex === currentStudents.length - 1;
            if (currentStudentIndex === currentStudents.length - 1) {
                finishEvaluationBtn.classList.remove('hidden');
                nextStudentBtn.classList.add('hidden');
            } else {
                finishEvaluationBtn.classList.add('hidden');
                nextStudentBtn.classList.remove('hidden');
            }
        }

        function evaluateAspect(studentName, aspect, level) {
            const evaluationKey = `${groupSelect.value}_${studentName}`;
            if (!evaluations[evaluationKey]) {
                evaluations[evaluationKey] = {};
            }
            evaluations[evaluationKey][aspect] = level;
            saveData();
            renderStudentEvaluation();
            showMessage(evaluationMessageBox, `Evaluación para '${aspect}' del estudiante '${studentName}' actualizada a '${level}'.`, 'success');
        }

        prevStudentBtn.addEventListener('click', () => {
            if (currentStudentIndex > 0) {
                currentStudentIndex--;
                renderStudentEvaluation();
            }
        });

        nextStudentBtn.addEventListener('click', () => {
            if (currentStudentIndex < currentStudents.length - 1) {
                currentStudentIndex++;
                renderStudentEvaluation();
            }
        });

        finishEvaluationBtn.addEventListener('click', () => {
            evaluationSection.classList.add('hidden');
            reportSection.classList.remove('hidden');
        });

        backToEvaluationBtn.addEventListener('click', () => {
            reportSection.classList.add('hidden');
            evaluationSection.classList.remove('hidden');
            renderStudentEvaluation();
        });

        newRubricBtn.addEventListener('click', () => {
            const confirmReset = window.confirm("¿Estás seguro de que quieres iniciar una nueva evaluación? Esto borrará las evaluaciones actuales pero mantendrá tus grupos y rúbricas guardadas.");
            if (confirmReset) {
                resetApp();
            }
        });

        // --- Lógica de Exportación a PDF y CSV ---

        function generateSingleStudentPdf(studentName, groupName) {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({
                orientation: 'landscape',
                unit: 'mm',
                format: 'a4'
            });

            doc.setFont("helvetica");
            let yOffset = 20;
            const margin = 20;

            doc.setFontSize(22);
            doc.setTextColor(40, 40, 40);
            doc.text("Rúbrica de Evaluación", doc.internal.pageSize.width / 2, yOffset, { align: 'center' });
            yOffset += 10;

            doc.setFontSize(14);
            doc.setTextColor(50, 50, 50);
            doc.text(`Grupo: ${groupName || 'N/A'}`, doc.internal.pageSize.width / 2, yOffset, { align: 'center' });
            yOffset += 10;

            doc.setFontSize(10);
            doc.setTextColor(80, 80, 80);
            doc.text(`Rúbrica: ${currentRubric.name || 'N/A'}`, margin, yOffset);
            yOffset += 5;
            doc.text(`Estudiante: ${studentName || 'N/A'}`, margin, yOffset);
            yOffset += 10;

            const headers = ["Aspecto", "Nivel Asignado", "Puntaje", "Descriptor"];
            const tableColumnWidths = [40, 25, 15, 90];

            const evaluationKey = `${groupName}_${studentName}`;
            const tableData = [];
            let studentTotalScore = 0;
            let hasEvaluatedAspects = false;

            currentRubric.aspects.forEach(aspect => {
                const assignedLevel = evaluations[evaluationKey] ? evaluations[evaluationKey][aspect] || 'No Evaluado' : 'No Evaluado';
                const scoreForAspect = currentRubric.levelScores[assignedLevel] || 0;
                const descriptorText = currentRubric.descriptors[aspect][assignedLevel] || 'N/A';
                tableData.push([aspect, assignedLevel, scoreForAspect, descriptorText]);

                if (assignedLevel !== 'No Evaluado') {
                    studentTotalScore += scoreForAspect;
                    hasEvaluatedAspects = true;
                }
            });

            let maxPossibleScore = 0;
            currentRubric.aspects.forEach(aspect => {
                let maxAspectScore = 0;
                currentRubric.levels.forEach(level => {
                    const score = currentRubric.levelScores[level] || 0;
                    if (score > maxAspectScore) {
                        maxAspectScore = score;
                    }
                });
                maxPossibleScore += maxAspectScore;
            });

            const studentAverageScore = hasEvaluatedAspects ? (studentTotalScore / currentRubric.aspects.length).toFixed(1) : 'N/A';
            const performanceLevel = getPerformanceLevel(parseFloat(studentAverageScore));

            doc.autoTable({
                startY: yOffset,
                head: [headers],
                body: tableData,
                theme: 'grid',
                styles: {
                    fontSize: 7,
                    cellPadding: 1.5,
                    valign: 'middle',
                    halign: 'left',
                    textColor: [50, 50, 50],
                },
                headStyles: {
                    fillColor: [220, 220, 220],
                    textColor: [0, 0, 0],
                    fontStyle: 'bold',
                },
                columnStyles: {
                    0: { cellWidth: tableColumnWidths[0] },
                    1: { cellWidth: tableColumnWidths[1] },
                    2: { cellWidth: tableColumnWidths[2], halign: 'center' },
                    3: { cellWidth: tableColumnWidths[3] }
                },
                didDrawPage: function (data) {
                    let str = "Página " + doc.internal.getNumberOfPages();
                    doc.setFontSize(8);
                    doc.setTextColor(150);
                    doc.text(str, data.settings.margin.left, doc.internal.pageSize.height - 10);
                }
            });

            yOffset = doc.autoTable.previous.finalY;

            doc.setFontSize(10);
            doc.setTextColor(0, 100, 0);
            doc.text(`Puntaje Final: ${studentTotalScore} / ${maxPossibleScore} pts`, margin, yOffset + 5);
            doc.text(`Promedio por Aspecto: ${studentAverageScore}`, margin, yOffset + 10);
            doc.text(`Nivel de Desempeño: ${performanceLevel.level}`, margin, yOffset + 15);
            yOffset += 25;

            const safeStudentName = studentName.replace(/[^a-z0-9]/gi, '_');
            const safeGroupName = groupName.replace(/[^a-z0-9]/gi, '_');
            doc.save(`rubrica_${safeStudentName}_${safeGroupName}.pdf`);
        }

        exportIndividualRubricsBtn.addEventListener('click', async () => {
            if (currentStudents.length === 0) {
                showMessage(reportMessageBox, "No hay estudiantes en el grupo actual para generar reportes individuales.", 'error');
                return;
            }
            if (!currentRubric) {
                showMessage(reportMessageBox, "No hay una rúbrica seleccionada para exportar.", 'error');
                return;
            }

            const currentGroupName = groupSelect.value;
            for (const student of currentStudents) {
                generateSingleStudentPdf(student, currentGroupName);
            }
            showMessage(reportMessageBox, "¡Rúbricas individuales generadas y descargadas!", 'success');
        });

        exportPdfBtn.addEventListener('click', async () => {
            if (currentStudents.length === 0) {
                showMessage(reportMessageBox, "No hay estudiantes en el grupo actual para generar el reporte.", 'error');
                return;
            }
            if (!currentRubric) {
                showMessage(reportMessageBox, "No hay una rúbrica seleccionada para exportar.", 'error');
                return;
            }

            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({
                orientation: 'landscape',
                unit: 'mm',
                format: 'a4'
            });

            doc.setFont("helvetica");

            const currentGroupName = groupSelect.value;
            let totalSumOfFinalScores = 0;
            let evaluatedStudentCount = 0;

            for (const student of currentStudents) {
                doc.addPage();
                let yOffset = 20;
                const margin = 20;

                doc.setFontSize(22);
                doc.setTextColor(40, 40, 40);
                doc.text("Rúbrica de Evaluación", doc.internal.pageSize.width / 2, yOffset, { align: 'center' });
                yOffset += 10;

                doc.setFontSize(14);
                doc.setTextColor(50, 50, 50);
                doc.text(`Grupo: ${currentGroupName || 'N/A'}`, doc.internal.pageSize.width / 2, yOffset, { align: 'center' });
                yOffset += 10;

                doc.setFontSize(10);
                doc.setTextColor(80, 80, 80);
                doc.text(`Rúbrica: ${currentRubric.name || 'N/A'}`, margin, yOffset);
                yOffset += 5;
                doc.text(`Estudiante: ${student || 'N/A'}`, margin, yOffset);
                yOffset += 10;

                const headers = ["Aspecto", "Nivel Asignado", "Puntaje", "Descriptor"];
                const tableColumnWidths = [40, 25, 15, 90];

                const evaluationKey = `${currentGroupName}_${student}`;
                const tableData = [];
                let studentTotalScore = 0;
                let hasEvaluatedAspects = false;

                currentRubric.aspects.forEach(aspect => {
                    const assignedLevel = evaluations[evaluationKey] ? evaluations[evaluationKey][aspect] || 'No Evaluado' : 'No Evaluado';
                    const scoreForAspect = currentRubric.levelScores[assignedLevel] || 0;
                    const descriptorText = currentRubric.descriptors[aspect][assignedLevel] || 'N/A';
                    tableData.push([aspect, assignedLevel, scoreForAspect, descriptorText]);

                    if (assignedLevel !== 'No Evaluado') {
                        studentTotalScore += scoreForAspect;
                        hasEvaluatedAspects = true;
                    }
                });

                if (hasEvaluatedAspects) {
                    totalSumOfFinalScores += studentTotalScore;
                    evaluatedStudentCount++;
                }

                let maxPossibleScore = 0;
                currentRubric.aspects.forEach(aspect => {
                    let maxAspectScore = 0;
                    currentRubric.levels.forEach(level => {
                        const score = currentRubric.levelScores[level] || 0;
                        if (score > maxAspectScore) {
                            maxAspectScore = score;
                        }
                    });
                    maxPossibleScore += maxAspectScore;
                });

                const studentAverageScore = hasEvaluatedAspects ? (studentTotalScore / currentRubric.aspects.length).toFixed(1) : 'N/A';
                const performanceLevel = getPerformanceLevel(parseFloat(studentAverageScore));

                doc.autoTable({
                    startY: yOffset,
                    head: [headers],
                    body: tableData,
                    theme: 'grid',
                    styles: {
                        fontSize: 7,
                        cellPadding: 1.5,
                        valign: 'middle',
                        halign: 'left',
                        textColor: [50, 50, 50],
                    },
                    headStyles: {
                        fillColor: [220, 220, 220],
                        textColor: [0, 0, 0],
                        fontStyle: 'bold',
                    },
                    columnStyles: {
                        0: { cellWidth: tableColumnWidths[0] },
                        1: { cellWidth: tableColumnWidths[1] },
                        2: { cellWidth: tableColumnWidths[2], halign: 'center' },
                        3: { cellWidth: tableColumnWidths[3] }
                    },
                    didDrawPage: function (data) {
                        let str = "Página " + doc.internal.getNumberOfPages();
                        doc.setFontSize(8);
                        doc.setTextColor(150);
                        doc.text(str, data.settings.margin.left, doc.internal.pageSize.height - 10);
                    }
                });

                yOffset = doc.autoTable.previous.finalY;

                doc.setFontSize(10);
                doc.setTextColor(0, 100, 0);
                doc.text(`Puntaje Final: ${studentTotalScore} / ${maxPossibleScore} pts`, margin, yOffset + 5);
                doc.text(`Promedio por Aspecto: ${studentAverageScore}`, margin, yOffset + 10);
                doc.text(`Nivel de Desempeño: ${performanceLevel.level}`, margin, yOffset + 15);
            }

            doc.save('rubricas_evaluacion_grupo.pdf');
            showMessage(reportMessageBox, "¡Reporte PDF generado y descargado!", 'success');
        });

        exportCsvBtn.addEventListener('click', () => {
            if (currentStudents.length === 0) {
                showMessage(reportMessageBox, "No hay estudiantes en el grupo actual para exportar.", 'error');
                return;
            }
            if (!currentRubric) {
                showMessage(reportMessageBox, "No hay una rúbrica seleccionada para exportar.", 'error');
                return;
            }

            const currentGroupName = groupSelect.value;
            let csvContent = "data:text/csv;charset=utf-8,";
            
            // Encabezados
            const headers = ["Estudiante", ...currentRubric.aspects, "Puntaje Total", "Promedio", "Nivel de Desempeño"];
            csvContent += headers.map(h => `"${h}"`).join(",") + "\r\n";

            currentStudents.forEach(student => {
                const evaluationKey = `${currentGroupName}_${student}`;
                let rowData = [student];
                let totalScore = 0;
                let evaluatedAspectsCount = 0;

                currentRubric.aspects.forEach(aspect => {
                    const assignedLevel = evaluations[evaluationKey] ? evaluations[evaluationKey][aspect] || '' : '';
                    const scoreForAspect = assignedLevel ? currentRubric.levelScores[assignedLevel] || 0 : 0;
                    
                    if (assignedLevel) {
                        totalScore += scoreForAspect;
                        evaluatedAspectsCount++;
                    }
                    
                    rowData.push(assignedLevel);
                });

                const averageScore = evaluatedAspectsCount > 0 ? (totalScore / evaluatedAspectsCount).toFixed(1) : 0;
                const performanceLevel = getPerformanceLevel(parseFloat(averageScore));
                
                rowData.push(totalScore);
                rowData.push(averageScore);
                rowData.push(performanceLevel.level);
                
                csvContent += rowData.map(item => `"${item}"`).join(",") + "\r\n";
            });

            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", `evaluaciones_${currentGroupName}.csv`);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            showMessage(reportMessageBox, "¡Datos exportados a CSV correctamente!", 'success');
        });

        // --- Inicialización ---

        window.onload = loadData;

    </script>
</body>
</html>
